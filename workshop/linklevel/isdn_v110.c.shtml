<HTML>

<!-- Generated by c2html-1.0, Copyright 1998 by Dave Whittington -->
<HEAD>
<TITLE>isdn_v110.c</TITLE>
<!--#include virtual="/ssi/js.shtml" -->
<!--#include virtual="/ssi/buttondefs.shtml" -->
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE WIDTH="100%">
<TR>
<TD ALIGN=LEFT WIDTH="90"><!--#include virtual="/ssi/b_home.shtml" --></TD>
<TD ALIGN=RIGHT WIDTH="90"><!--#include virtual="/ssi/b_index.shtml" --></TD>
</TR>
</TABLE>
<CENTER><H1>isdn_v110.c</H1></CENTER>

<HR>
<PRE>
<FONT COLOR=#0000FF>/* $Id$

 * Linux ISDN subsystem, V.110 related functions (linklevel).
 *
 * Copyright by Thomas Pfeiffer (pfeiffer@pds.de)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * $Log$
 * Revision 1.2  1998/02/22 19:44:25  fritz
 * Bugfixes and improvements regarding V.110, V.110 now running.
 *
 * Revision 1.1  1998/02/20 17:32:09  fritz
 * First checkin (not yet completely functionable).
 *
 */</FONT>
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/string.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/kernel.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/malloc.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/mm.h&gt;

<FONT COLOR=#A521F7>#include</FONT> &lt;linux/isdn.h&gt;
<FONT COLOR=#A521F7>#include</FONT> <FONT COLOR="#FF0000">"isdn_v110.h"</FONT>

<FONT COLOR=#A521F7>#undef</FONT> ISDN_V110_DEBUG

<FONT COLOR="#298C52">char</FONT> *isdn_v110_revision = <FONT COLOR="#FF0000">"$Revision$"</FONT>;

<FONT COLOR=#A521F7>#define</FONT> <A NAME="V110_38400">V110_38400</A> 255
<FONT COLOR=#A521F7>#define</FONT> <A NAME="V110_19200">V110_19200</A>  15
<FONT COLOR=#A521F7>#define</FONT> <A NAME="V110_9600">V110_9600</A>    3

<FONT COLOR=#0000FF>/* Die folgenden Daten sind fertig kodierte Matrizen, jeweils
   als online und offline matrix für 9600, 19200 und 38400
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> V110_OnMatrix_9600[] =
{0xfc, 0xfc, 0xfc, 0xfc, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff,
 0xff, 0xfd, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xfd,
 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff,
 0xff, 0xfd, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xfd};

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> V110_OffMatrix_9600[] =
{0xfc, 0xfc, 0xfc, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> V110_OnMatrix_19200[] =
{0xf0, 0xf0, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7,
 0xfd, 0xff, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7, 0xff, 0xf7};

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> V110_OffMatrix_19200[] =
{0xf0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> V110_OnMatrix_38400[] =
{0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0xfd, 0x7f, 0x7f, 0x7f, 0x7f};

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> V110_OffMatrix_38400[] =
{0x00, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff};


<FONT COLOR=#0000FF>/* FlipBits dreht die Reihenfolge von jeweils keylen bits in einem byte um.
   Aus der Bitreihenfolge 76543210 werden bei keylen=4 die bits 45670123,
   bei keylen=2 die bits 67452301. Dies ist notwendig, weil die reihenfolge
   auf der isdn-leitung falsch herum ist.
 */</FONT>

<FONT COLOR="#298C52">static</FONT> __inline <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT>
<A NAME="FlipBits">FlipBits</A>(<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> c, <FONT COLOR="#298C52">int</FONT> keylen)
{
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> b = c;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> bit = 128;
	<FONT COLOR="#298C52">int</FONT> i;
	<FONT COLOR="#298C52">int</FONT> j;
	<FONT COLOR="#298C52">int</FONT> hunks = (8 / keylen);

	c = 0;
	<FONT COLOR="#298C52">for</FONT> (i = 0; i &lt; hunks; i++) {
		<FONT COLOR="#298C52">for</FONT> (j = 0; j &lt; keylen; j++) {
			<FONT COLOR="#298C52">if</FONT> (b &amp; (bit &gt;&gt; j))
				c |= bit &gt;&gt; (keylen - j - 1);
		}
		bit &gt;&gt;= keylen;
	}
	<FONT COLOR="#298C52">return</FONT> c;
}


<FONT COLOR=#0000FF>/* isdn_v110_open allocates and initializes private V.110 data
 * structures and returns a pointer to these.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> *
<A HREF="#isdn_v110_open">isdn_v110_open</A>(<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> key, <FONT COLOR="#298C52">int</FONT> hdrlen, <FONT COLOR="#298C52">int</FONT> maxsize)
{
	<FONT COLOR="#298C52">int</FONT> i;
	<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> *v;

	<FONT COLOR="#298C52">if</FONT> ((v = kmalloc(<FONT COLOR="#298C52">sizeof</FONT>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A>), GFP_KERNEL)) == NULL)
		<FONT COLOR="#298C52">return</FONT> NULL;
	memset(v, 0, <FONT COLOR="#298C52">sizeof</FONT>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A>));
	v-&gt;key = key;
	v-&gt;nbits = 0;
	<FONT COLOR="#298C52">for</FONT> (i = 0; key &amp; (1 &lt;&lt; i); i++)
		v-&gt;nbits++;

	v-&gt;nbytes = 8 / v-&gt;nbits;
	v-&gt;decodelen = 0;

	<FONT COLOR="#298C52">switch</FONT> (key) {
		<FONT COLOR="#298C52">case</FONT> <A HREF="#V110_38400">V110_38400</A>:
			v-&gt;OnlineFrame = V110_OnMatrix_38400;
			v-&gt;OfflineFrame = V110_OffMatrix_38400;
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> <A HREF="#V110_19200">V110_19200</A>:
			v-&gt;OnlineFrame = V110_OnMatrix_19200;
			v-&gt;OfflineFrame = V110_OffMatrix_19200;
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">default</FONT>:
			v-&gt;OnlineFrame = V110_OnMatrix_9600;
			v-&gt;OfflineFrame = V110_OffMatrix_9600;
			<FONT COLOR="#298C52">break</FONT>;
	}
	v-&gt;framelen = v-&gt;nbytes * 10;
	v-&gt;SyncInit = 5;
	v-&gt;introducer = 0;
	v-&gt;dbit = 1;
	v-&gt;b = 0;
	v-&gt;skbres = hdrlen;
	v-&gt;maxsize = maxsize - hdrlen;
	<FONT COLOR="#298C52">if</FONT> ((v-&gt;encodebuf = kmalloc(maxsize, GFP_KERNEL)) == NULL) {
		kfree(v);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	<FONT COLOR="#298C52">return</FONT> v;
}

<FONT COLOR=#0000FF>/* isdn_v110_close frees private V.110 data structures */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
<A NAME="isdn_v110_close">isdn_v110_close</A>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> * v)
{
	<FONT COLOR="#298C52">if</FONT> (v == NULL)
		<FONT COLOR="#298C52">return</FONT>;
<FONT COLOR=#A521F7>#ifdef</FONT> ISDN_V110_DEBUG
	printk(KERN_DEBUG <FONT COLOR="#FF0000">"v110 close\n"</FONT>);
<FONT COLOR=#A521F7>#if</FONT> 0
	printk(KERN_DEBUG <FONT COLOR="#FF0000">"isdn_v110_close: nbytes=%d\n"</FONT>, v-&gt;nbytes);
	printk(KERN_DEBUG <FONT COLOR="#FF0000">"isdn_v110_close: nbits=%d\n"</FONT>, v-&gt;nbits);
	printk(KERN_DEBUG <FONT COLOR="#FF0000">"isdn_v110_close: key=%d\n"</FONT>, v-&gt;key);
	printk(KERN_DEBUG <FONT COLOR="#FF0000">"isdn_v110_close: SyncInit=%d\n"</FONT>, v-&gt;SyncInit);
	printk(KERN_DEBUG <FONT COLOR="#FF0000">"isdn_v110:close: decodelen=%d\n"</FONT>, v-&gt;decodelen);
	printk(KERN_DEBUG <FONT COLOR="#FF0000">"isdn_v110_close: framelen=%d\n"</FONT>, v-&gt;framelen);
<FONT COLOR=#A521F7>#endif</FONT>
<FONT COLOR=#A521F7>#endif</FONT>
	kfree(v-&gt;encodebuf);
	kfree(v);
}


<FONT COLOR=#0000FF>/* ValidHeaderBytes prüft, wieviele bytes in v-&gt;decodebuf gültig sind */</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">int</FONT>
<A NAME="ValidHeaderBytes">ValidHeaderBytes</A>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> * v)
{
	<FONT COLOR="#298C52">int</FONT> i;
	<FONT COLOR="#298C52">for</FONT> (i = 0; (i &lt; v-&gt;decodelen) &amp;&amp; (i &lt; v-&gt;nbytes); i++)
		<FONT COLOR="#298C52">if</FONT> ((v-&gt;decodebuf[i] &amp; v-&gt;key) != 0)
			<FONT COLOR="#298C52">break</FONT>;
	<FONT COLOR="#298C52">return</FONT> i;
}

<FONT COLOR=#0000FF>/* SyncHeader schiebt den decodebuf pointer auf den nächsten gültigen header */</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
<A NAME="SyncHeader">SyncHeader</A>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> * v)
{
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *rbuf = v-&gt;decodebuf;
	<FONT COLOR="#298C52">int</FONT> len = v-&gt;decodelen;

	<FONT COLOR="#298C52">if</FONT> (len == 0)
		<FONT COLOR="#298C52">return</FONT>;
	<FONT COLOR="#298C52">for</FONT> (rbuf++, len--; len &gt; 0; len--, rbuf++)	<FONT COLOR=#0000FF>/* such den SyncHeader in buf ! */</FONT>
		<FONT COLOR="#298C52">if</FONT> ((*rbuf &amp; v-&gt;key) == 0)	<FONT COLOR=#0000FF>/* erstes byte gefunden ?       */</FONT>
			<FONT COLOR="#298C52">break</FONT>;  <FONT COLOR=#0000FF>/* jupp!                        */</FONT>
	<FONT COLOR="#298C52">if</FONT> (len)
		memcpy(v-&gt;decodebuf, rbuf, len);

	v-&gt;decodelen = len;
<FONT COLOR=#A521F7>#ifdef</FONT> ISDN_V110_DEBUG
	printk(KERN_DEBUG <FONT COLOR="#FF0000">"isdn_v110: Header resync\n"</FONT>);
<FONT COLOR=#A521F7>#endif</FONT>
}

<FONT COLOR=#0000FF>/* DecodeMatrix takes n (n&gt;=1) matrices (v110 frames, 10 bytes) where
   len is the number of matrix-lines. len must be a multiple of 10, i.e.
   only complete matices must be given.
   From these, netto data is extracted and returned in buf. The return-value
   is the bytecount of the decoded data.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">int</FONT>
<A HREF="#DecodeMatrix">DecodeMatrix</A>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> * v, <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *m, <FONT COLOR="#298C52">int</FONT> len, <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *buf)
{
	<FONT COLOR="#298C52">int</FONT> line = 0;
	<FONT COLOR="#298C52">int</FONT> buflen = 0;
	<FONT COLOR="#298C52">int</FONT> mbit = 64;
	<FONT COLOR="#298C52">int</FONT> introducer = v-&gt;introducer;
	<FONT COLOR="#298C52">int</FONT> dbit = v-&gt;dbit;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> b = v-&gt;b;

	<FONT COLOR="#298C52">while</FONT> (line &lt; len) {    <FONT COLOR=#0000FF>/* sind schon alle matrizenzeilen abgearbeitet? */</FONT>
		<FONT COLOR="#298C52">if</FONT> ((line % 10) == 0) {	<FONT COLOR=#0000FF>/* die 0. zeile der matrix ist immer null ! */</FONT>
			<FONT COLOR="#298C52">if</FONT> (m[line] != 0x00) {	<FONT COLOR=#0000FF>/* nicht 0 ? dann fehler! */</FONT>
<FONT COLOR=#A521F7>#ifdef</FONT> ISDN_V110_DEBUG
				printk(KERN_DEBUG <FONT COLOR="#FF0000">"isdn_v110: DecodeMatrix, V110 Bad Header\n"</FONT>);
<FONT COLOR=#A521F7>#endif</FONT>

<FONT COLOR=#0000FF>/*
  dann einen return zu machen, ist auch irgendwie nicht das richtige! :-(
  v-&gt;introducer = 0; v-&gt;dbit = 1; v-&gt;b = 0;
  return buflen;                                                                                                     anzahl schon erzeugter daten zurückgeben!
  */</FONT>
			}
			line++; <FONT COLOR=#0000FF>/* sonst die nächste matrixzeile nehmen */</FONT>
			<FONT COLOR="#298C52">continue</FONT>;
		} <FONT COLOR="#298C52">else</FONT> <FONT COLOR="#298C52">if</FONT> ((line % 10) == 5) {	<FONT COLOR=#0000FF>/* in zeile 5 stehen nur e-bits ! */</FONT>
			<FONT COLOR="#298C52">if</FONT> ((m[line] &amp; 0x70) != 0x30) {	<FONT COLOR=#0000FF>/* 011 muß am anfang stehen! */</FONT>
<FONT COLOR=#A521F7>#ifdef</FONT> ISDN_V110_DEBUG
				printk(KERN_DEBUG <FONT COLOR="#FF0000">"isdn_v110: DecodeMatrix, V110 Bad 5th line\n"</FONT>);
<FONT COLOR=#A521F7>#endif</FONT>
<FONT COLOR=#0000FF>/* dann einen return zu machen, ist auch irgendwie nicht das richtige! :-(
   v-&gt;introducer = 0; v-&gt;dbit = 1; v-&gt;b = 0;
   return buflen;
 */</FONT>
			}
			line++; <FONT COLOR=#0000FF>/* alles klar, nächste zeile */</FONT>
			<FONT COLOR="#298C52">continue</FONT>;
		} <FONT COLOR="#298C52">else</FONT> <FONT COLOR="#298C52">if</FONT> (!introducer) {	<FONT COLOR=#0000FF>/* every byte starts with 10 (stopbit, startbit) */</FONT>
			introducer = (m[line] &amp; mbit) ? 0 : 1;	<FONT COLOR=#0000FF>/* aktuelles bit der matrix */</FONT>
		      next_byte:
			<FONT COLOR="#298C52">if</FONT> (mbit &gt; 2) {	<FONT COLOR=#0000FF>/* war es das letzte bit dieser matrixzeile ? */</FONT>
				mbit &gt;&gt;= 1;	<FONT COLOR=#0000FF>/* nein, nimm das nächste in dieser zeile */</FONT>
				<FONT COLOR="#298C52">continue</FONT>;
			}       <FONT COLOR=#0000FF>/* sonst links in der nächsten zeile anfangen */</FONT>
			mbit = 64;
			line++;
			<FONT COLOR="#298C52">continue</FONT>;
		} <FONT COLOR="#298C52">else</FONT> {        <FONT COLOR=#0000FF>/* sonst müssen wir ein datenbit setzen */</FONT>
			<FONT COLOR="#298C52">if</FONT> (m[line] &amp; mbit)	<FONT COLOR=#0000FF>/* war das bit in der matrix gesetzt ? */</FONT>
				b |= dbit;	<FONT COLOR=#0000FF>/* ja, dann setz es auch im datenbyte  */</FONT>
			<FONT COLOR="#298C52">else</FONT>
				b &amp;= dbit - 1;	<FONT COLOR=#0000FF>/* nein, lösch bit im datenbyte */</FONT>
			<FONT COLOR="#298C52">if</FONT> (dbit &lt; 128)	<FONT COLOR=#0000FF>/* haben wir schon ein ganzes byte voll ? */</FONT>
				dbit &lt;&lt;= 1;	<FONT COLOR=#0000FF>/* nein, auf zum nächsten datenbit */</FONT>
			<FONT COLOR="#298C52">else</FONT> {  <FONT COLOR=#0000FF>/* ein ganzes datenbyte ist voll */</FONT>
				buf[buflen++] = b;	<FONT COLOR=#0000FF>/* byte in den output buffer kopieren */</FONT>
				introducer = b = 0;	<FONT COLOR=#0000FF>/* Init der Introsequenz und des datenbytes */</FONT>
				dbit = 1;	<FONT COLOR=#0000FF>/* als nächstes suchen wir das nullte bit */</FONT>
			}
			<FONT COLOR="#298C52">goto</FONT> next_byte;	<FONT COLOR=#0000FF>/* suche das nächste bit in der matrix */</FONT>
		}
	}
	v-&gt;introducer = introducer;
	v-&gt;dbit = dbit;
	v-&gt;b = b;
	<FONT COLOR="#298C52">return</FONT> buflen;          <FONT COLOR=#0000FF>/* return anzahl der bytes im output buffer */</FONT>
}

<FONT COLOR=#0000FF>/* DecodeStream erhält vom input stream V110 kodierte Daten, die zu den
   V110 frames zusammengepackt werden müssen. Die Daten können an diese
   Schnittstelle so übergeben werden, wie sie von der Leitung kommen, ohne
   darauf achten zu müssen, das frames usw. eingehalten werden.
 */</FONT>
<FONT COLOR="#298C52">struct</FONT> sk_buff *
<A HREF="#isdn_v110_decode">isdn_v110_decode</A>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> * v, <FONT COLOR="#298C52">struct</FONT> sk_buff *skb)
{
	<FONT COLOR="#298C52">int</FONT> i;
	<FONT COLOR="#298C52">int</FONT> j;
	<FONT COLOR="#298C52">int</FONT> len;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *v110_buf;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *rbuf;

	<FONT COLOR="#298C52">if</FONT> (!skb) {
		printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110_decode called with NULL skb!\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	rbuf = skb-&gt;data;
	len = skb-&gt;len;
	<FONT COLOR="#298C52">if</FONT> (v == NULL) {
		<FONT COLOR=#0000FF>/* invalid handle, no chance to proceed */</FONT>
		printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110_decode called with NULL stream!\n"</FONT>);
		dev_kfree_skb(skb);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	<FONT COLOR="#298C52">if</FONT> (v-&gt;decodelen == 0)  <FONT COLOR=#0000FF>/* cache empty?               */</FONT>
		<FONT COLOR="#298C52">for</FONT> (; len &gt; 0; len--, rbuf++)	<FONT COLOR=#0000FF>/* scan for SyncHeader in buf */</FONT>
			<FONT COLOR="#298C52">if</FONT> ((*rbuf &amp; v-&gt;key) == 0)
				<FONT COLOR="#298C52">break</FONT>;	<FONT COLOR=#0000FF>/* found first byte           */</FONT>
	<FONT COLOR="#298C52">if</FONT> (len == 0) {
		dev_kfree_skb(skb);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	<FONT COLOR=#0000FF>/* copy new data to decode-buffer */</FONT>
	memcpy(&amp;(v-&gt;decodebuf[v-&gt;decodelen]), rbuf, len);
	v-&gt;decodelen += len;
      ReSync:
	<FONT COLOR="#298C52">if</FONT> (v-&gt;decodelen &lt; v-&gt;nbytes) {	<FONT COLOR=#0000FF>/* got a new header ? */</FONT>
		dev_kfree_skb(skb);
		<FONT COLOR="#298C52">return</FONT> NULL;    <FONT COLOR=#0000FF>/* no, try later      */</FONT>
	}
	<FONT COLOR="#298C52">if</FONT> (<A HREF="#ValidHeaderBytes">ValidHeaderBytes</A>(v) != v-&gt;nbytes) {	<FONT COLOR=#0000FF>/* ist es ein ungültiger header ? */</FONT>
		<A HREF="#SyncHeader">SyncHeader</A>(v);  <FONT COLOR=#0000FF>/* nein, such einen header */</FONT>
		<FONT COLOR="#298C52">goto</FONT> ReSync;
	}
	len = (v-&gt;decodelen - (v-&gt;decodelen % (10 * v-&gt;nbytes))) / v-&gt;nbytes;
	<FONT COLOR="#298C52">if</FONT> ((v110_buf = kmalloc(len, GFP_ATOMIC)) == NULL) {
		printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110_decode: Couldn't allocate v110_buf\n"</FONT>);
		dev_kfree_skb(skb);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	<FONT COLOR="#298C52">for</FONT> (i = 0; i &lt; len; i++) {
		v110_buf[i] = 0;
		<FONT COLOR="#298C52">for</FONT> (j = 0; j &lt; v-&gt;nbytes; j++)
			v110_buf[i] |= (v-&gt;decodebuf[(i * v-&gt;nbytes) + j] &amp; v-&gt;key) &lt;&lt; (8 - ((j + 1) * v-&gt;nbits));
		v110_buf[i] = <A HREF="#FlipBits">FlipBits</A>(v110_buf[i], v-&gt;nbits);
	}
	v-&gt;decodelen = (v-&gt;decodelen % (10 * v-&gt;nbytes));
	memcpy(v-&gt;decodebuf, &amp;(v-&gt;decodebuf[len * v-&gt;nbytes]), v-&gt;decodelen);

	skb_trim(skb, <A HREF="#DecodeMatrix">DecodeMatrix</A>(v, v110_buf, len, skb-&gt;data));
	kfree(v110_buf);
	<FONT COLOR="#298C52">if</FONT> (skb-&gt;len)
		<FONT COLOR="#298C52">return</FONT> skb;
	<FONT COLOR="#298C52">else</FONT> {
		kfree_skb(skb);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
}

<FONT COLOR=#0000FF>/* EncodeMatrix takes input data in buf, len is the bytecount.
   Data is encoded into v110 frames in m. Return value is the number of
   matrix-lines generated.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">int</FONT>
<A HREF="#EncodeMatrix">EncodeMatrix</A>(<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *buf, <FONT COLOR="#298C52">int</FONT> len, <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *m, <FONT COLOR="#298C52">int</FONT> mlen)
{
	<FONT COLOR="#298C52">int</FONT> line = 0;
	<FONT COLOR="#298C52">int</FONT> i = 0;
	<FONT COLOR="#298C52">int</FONT> mbit = 128;
	<FONT COLOR="#298C52">int</FONT> dbit = 1;
	<FONT COLOR="#298C52">int</FONT> introducer = 3;
	<FONT COLOR="#298C52">int</FONT> ibit[] = {0, 1, 1};

	<FONT COLOR="#298C52">while</FONT> ((i &lt; len) &amp;&amp; (line &lt; mlen)) {	<FONT COLOR=#0000FF>/* solange noch input da ist */</FONT>
		<FONT COLOR="#298C52">switch</FONT> (line % 10) {	<FONT COLOR=#0000FF>/* in welcher matrixzeile sind wir ? */</FONT>
			<FONT COLOR="#298C52">case</FONT> 0:
				m[line++] = 0x00;	<FONT COLOR=#0000FF>/* zeile 0 ist immer 0 */</FONT>
				mbit = 128;	<FONT COLOR=#0000FF>/* und es geht mit dem 7. bit weiter */</FONT>
				<FONT COLOR="#298C52">break</FONT>;
			<FONT COLOR="#298C52">case</FONT> 5:
				m[line++] = 0xbf;	<FONT COLOR=#0000FF>/* zeile 5 ist immer 10111111 */</FONT>
				mbit = 128;	<FONT COLOR=#0000FF>/* und es geht mit dem 7. bit weiter */</FONT>
				<FONT COLOR="#298C52">break</FONT>;
		}
		<FONT COLOR="#298C52">if</FONT> (line &gt;= mlen) {
			printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110 (EncodeMatrix): buffer full!\n"</FONT>);
			<FONT COLOR="#298C52">return</FONT> line;
		}
	next_bit:
		<FONT COLOR="#298C52">switch</FONT> (mbit) { <FONT COLOR=#0000FF>/* ganz linkes oder rechtes bit ? */</FONT>
			<FONT COLOR="#298C52">case</FONT> 1:
				line++;	<FONT COLOR=#0000FF>/* ganz rechts ! dann in die nächste */</FONT>
				<FONT COLOR="#298C52">if</FONT> (line &gt;= mlen) {
					printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110 (EncodeMatrix): buffer full!\n"</FONT>);
					<FONT COLOR="#298C52">return</FONT> line;
				}
			<FONT COLOR="#298C52">case</FONT> 128:
				m[line] = 128;	<FONT COLOR=#0000FF>/* ganz links byte auf 1000000 setzen */</FONT>
				mbit = 64;	<FONT COLOR=#0000FF>/* aktuelles bit in der matrixzeile */</FONT>
				<FONT COLOR="#298C52">continue</FONT>;
		}
		<FONT COLOR="#298C52">if</FONT> (introducer) {	<FONT COLOR=#0000FF>/* 110 sequenz setzen ? */</FONT>
			introducer--;	<FONT COLOR=#0000FF>/* ein digit weniger setzen */</FONT>
			m[line] |= ibit[introducer] ? mbit : 0;	<FONT COLOR=#0000FF>/* entsprechendes bit setzen */</FONT>
			mbit &gt;&gt;= 1;	<FONT COLOR=#0000FF>/* bit der matrixzeile &gt;&gt; 1 */</FONT>
			<FONT COLOR="#298C52">goto</FONT> next_bit;	<FONT COLOR=#0000FF>/* und dort weiter machen */</FONT>
		}               <FONT COLOR=#0000FF>/* else datenbits in die matrix packen! */</FONT>
		m[line] |= (buf[i] &amp; dbit) ? mbit : 0;	<FONT COLOR=#0000FF>/* datenbit in matrix setzen */</FONT>
		<FONT COLOR="#298C52">if</FONT> (dbit == 128) {	<FONT COLOR=#0000FF>/* war es das letzte datenbit ? */</FONT>
			dbit = 1;	<FONT COLOR=#0000FF>/* dann mach beim nächsten weiter */</FONT>
			i++;    <FONT COLOR=#0000FF>/* nächste datenbyte des input buffers */</FONT>
			<FONT COLOR="#298C52">if</FONT> (i &lt; len)	<FONT COLOR=#0000FF>/* war es schon das letzte ? */</FONT>
				introducer = 3;	<FONT COLOR=#0000FF>/* nein, schreib den introducer 110 */</FONT>
			<FONT COLOR="#298C52">else</FONT> {  <FONT COLOR=#0000FF>/* war das letzte datenbyte ! */</FONT>
				m[line] |= (mbit - 1) &amp; 0xfe;	<FONT COLOR=#0000FF>/* setz restliche bits der zeile auf 1 */</FONT>
				<FONT COLOR="#298C52">break</FONT>;
			}
		} <FONT COLOR="#298C52">else</FONT>          <FONT COLOR=#0000FF>/* nicht das letzte datenbit */</FONT>
			dbit &lt;&lt;= 1;	<FONT COLOR=#0000FF>/* dann gehe zum nächsten datenbit */</FONT>
		mbit &gt;&gt;= 1;     <FONT COLOR=#0000FF>/* und setz bit der matrix weiter */</FONT>
		<FONT COLOR="#298C52">goto</FONT> next_bit;

	}
	<FONT COLOR=#0000FF>/* evtl. noch restliche zeilen in der matrix generieren... */</FONT>
	<FONT COLOR="#298C52">if</FONT> ((line) &amp;&amp; ((line + 10) &lt; mlen))
		<FONT COLOR="#298C52">switch</FONT> (++line % 10) {
			<FONT COLOR="#298C52">case</FONT> 1:
				m[line++] = 0xfe;
			<FONT COLOR="#298C52">case</FONT> 2:
				m[line++] = 0xfe;
			<FONT COLOR="#298C52">case</FONT> 3:
				m[line++] = 0xfe;
			<FONT COLOR="#298C52">case</FONT> 4:
				m[line++] = 0xfe;
			<FONT COLOR="#298C52">case</FONT> 5:
				m[line++] = 0xbf;
			<FONT COLOR="#298C52">case</FONT> 6:
				m[line++] = 0xfe;
			<FONT COLOR="#298C52">case</FONT> 7:
				m[line++] = 0xfe;
			<FONT COLOR="#298C52">case</FONT> 8:
				m[line++] = 0xfe;
			<FONT COLOR="#298C52">case</FONT> 9:
				m[line++] = 0xfe;
		}
	<FONT COLOR="#298C52">return</FONT> line;            <FONT COLOR=#0000FF>/* soviele matrixzeilen sind es */</FONT>
}

<FONT COLOR=#0000FF>/*
 * Build a sync frame.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">struct</FONT> sk_buff *
<A NAME="isdn_v110_sync">isdn_v110_sync</A>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> *v)
{
	<FONT COLOR="#298C52">struct</FONT> sk_buff *skb;

	<FONT COLOR="#298C52">if</FONT> (v == NULL) {
		<FONT COLOR=#0000FF>/* invalid handle, no chance to proceed */</FONT>
		printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110_sync called with NULL stream!\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	<FONT COLOR="#298C52">if</FONT> ((skb = dev_alloc_skb(v-&gt;framelen + v-&gt;skbres))) {
		skb_reserve(skb, v-&gt;skbres);
		memcpy(skb_put(skb, v-&gt;framelen), v-&gt;OfflineFrame, v-&gt;framelen);
	}
	<FONT COLOR="#298C52">return</FONT> skb;
}

<FONT COLOR=#0000FF>/*
 * Build an idle frame.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">struct</FONT> sk_buff *
<A NAME="isdn_v110_idle">isdn_v110_idle</A>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> *v)
{
	<FONT COLOR="#298C52">struct</FONT> sk_buff *skb;

	<FONT COLOR="#298C52">if</FONT> (v == NULL) {
		<FONT COLOR=#0000FF>/* invalid handle, no chance to proceed */</FONT>
		printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110_sync called with NULL stream!\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	<FONT COLOR="#298C52">if</FONT> ((skb = dev_alloc_skb(v-&gt;framelen + v-&gt;skbres))) {
		skb_reserve(skb, v-&gt;skbres);
		memcpy(skb_put(skb, v-&gt;framelen), v-&gt;OnlineFrame, v-&gt;framelen);
	}
	<FONT COLOR="#298C52">return</FONT> skb;
}

<FONT COLOR="#298C52">struct</FONT> sk_buff *
<A HREF="#isdn_v110_encode">isdn_v110_encode</A>(<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> * v, <FONT COLOR="#298C52">struct</FONT> sk_buff *skb)
{
	<FONT COLOR="#298C52">int</FONT> i;
	<FONT COLOR="#298C52">int</FONT> j;
	<FONT COLOR="#298C52">int</FONT> rlen;
	<FONT COLOR="#298C52">int</FONT> mlen;
	<FONT COLOR="#298C52">int</FONT> olen;
	<FONT COLOR="#298C52">int</FONT> size;
	<FONT COLOR="#298C52">int</FONT> sval1;
	<FONT COLOR="#298C52">int</FONT> sval2;
	<FONT COLOR="#298C52">int</FONT> nframes;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *v110buf;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *rbuf;
	<FONT COLOR="#298C52">struct</FONT> sk_buff *nskb;

	<FONT COLOR="#298C52">if</FONT> (v == NULL) {
		<FONT COLOR=#0000FF>/* invalid handle, no chance to proceed */</FONT>
		printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110_encode called with NULL stream!\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	<FONT COLOR="#298C52">if</FONT> (!skb) {
		<FONT COLOR=#0000FF>/* invalid skb, no chance to proceed */</FONT>
		printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110_encode called with NULL skb!\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	rlen = skb-&gt;len;
	nframes = (rlen + 3) / 4;
	v110buf = v-&gt;encodebuf;
	<FONT COLOR="#298C52">if</FONT> ((nframes * 40) &gt; v-&gt;maxsize) {
		size = v-&gt;maxsize;
		rlen = v-&gt;maxsize / 40;
	} <FONT COLOR="#298C52">else</FONT>
		size = nframes * 40;
	<FONT COLOR="#298C52">if</FONT> (!(nskb = dev_alloc_skb(size + v-&gt;skbres + <FONT COLOR="#298C52">sizeof</FONT>(<FONT COLOR="#298C52">int</FONT>)))) {
		printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110_encode: Couldn't alloc skb\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}
	skb_reserve(nskb, v-&gt;skbres + <FONT COLOR="#298C52">sizeof</FONT>(<FONT COLOR="#298C52">int</FONT>));
	<FONT COLOR="#298C52">if</FONT> (skb-&gt;len == 0) {
		memcpy(skb_put(nskb, v-&gt;framelen), v-&gt;OnlineFrame, v-&gt;framelen);
		*((<FONT COLOR="#298C52">int</FONT> *)skb_push(nskb, <FONT COLOR="#298C52">sizeof</FONT>(<FONT COLOR="#298C52">int</FONT>))) = 0;
		<FONT COLOR="#298C52">return</FONT> nskb;
	}
	mlen = <A HREF="#EncodeMatrix">EncodeMatrix</A>(skb-&gt;data, rlen, v110buf, size);
	<FONT COLOR=#0000FF>/* jetzt noch jeweils 2 oder 4 bits auf den output stream verteilen! */</FONT>
	rbuf = skb_put(nskb, size);
	olen = 0;
	sval1 = 8 - v-&gt;nbits;
	sval2 = v-&gt;key &lt;&lt; sval1;
	<FONT COLOR="#298C52">for</FONT> (i = 0; i &lt; mlen; i++) {
		v110buf[i] = <A HREF="#FlipBits">FlipBits</A>(v110buf[i], v-&gt;nbits);
		<FONT COLOR="#298C52">for</FONT> (j = 0; j &lt; v-&gt;nbytes; j++) {
			<FONT COLOR="#298C52">if</FONT> (size--)
				*rbuf++ = ~v-&gt;key | (((v110buf[i] &lt;&lt; (j * v-&gt;nbits)) &amp; sval2) &gt;&gt; sval1);
			<FONT COLOR="#298C52">else</FONT> {
				printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110_encode: buffers full!\n"</FONT>);
				<FONT COLOR="#298C52">goto</FONT> buffer_full;
			}
			olen++;
		}
	}
buffer_full:
	skb_trim(nskb, olen);
	*((<FONT COLOR="#298C52">int</FONT> *)skb_push(nskb, <FONT COLOR="#298C52">sizeof</FONT>(<FONT COLOR="#298C52">int</FONT>))) = rlen;
	<FONT COLOR="#298C52">return</FONT> nskb;
}

<FONT COLOR="#298C52">int</FONT>
<A NAME="isdn_v110_stat_callback">isdn_v110_stat_callback</A>(<FONT COLOR="#298C52">int</FONT> idx, <A HREF="../includes/isdnif.h.shtml#isdn_ctrl">isdn_ctrl</A> * c)
{
	<A HREF="../includes/isdn.h.shtml#isdn_v110_stream">isdn_v110_stream</A> *v = NULL;
	<FONT COLOR="#298C52">int</FONT> i;
	<FONT COLOR="#298C52">int</FONT> ret;

	<FONT COLOR="#298C52">if</FONT> (idx &lt; 0)
		<FONT COLOR="#298C52">return</FONT> 0;
	<FONT COLOR="#298C52">switch</FONT> (c-&gt;command) {
		<FONT COLOR="#298C52">case</FONT> <A HREF="../includes/isdnif.h.shtml#ISDN_STAT_BSENT">ISDN_STAT_BSENT</A>:
                        <FONT COLOR=#0000FF>/* Keep the send-queue of the driver filled
			 * with frames:
			 * If number of outstanding frames &lt; 3,
			 * send down an Idle-Frame (or an Sync-Frame, if
			 * v-&gt;SyncInit != 0). 
			 */</FONT>
			<FONT COLOR="#298C52">if</FONT> (!(v = dev-&gt;v110[idx]))
				<FONT COLOR="#298C52">return</FONT> 0;
			atomic_inc(&amp;dev-&gt;v110use[idx]);
			<FONT COLOR="#298C52">if</FONT> (v-&gt;skbidle &gt; 0) {
				v-&gt;skbidle--;
				ret = 1;
			} <FONT COLOR="#298C52">else</FONT> {
				<FONT COLOR="#298C52">if</FONT> (v-&gt;skbuser &gt; 0)
					v-&gt;skbuser--;
				ret = 0;
			}
			<FONT COLOR="#298C52">for</FONT> (i = v-&gt;skbuser + v-&gt;skbidle; i &lt; 2; i++) {
				<FONT COLOR="#298C52">struct</FONT> sk_buff *skb;
				<FONT COLOR="#298C52">if</FONT> (v-&gt;SyncInit &gt; 0)
					skb = <A HREF="#isdn_v110_sync">isdn_v110_sync</A>(v);
				<FONT COLOR="#298C52">else</FONT>
					skb = <A HREF="#isdn_v110_idle">isdn_v110_idle</A>(v);
				<FONT COLOR="#298C52">if</FONT> (skb) {
					<FONT COLOR="#298C52">if</FONT> (dev-&gt;drv[c-&gt;<A HREF="../includes/isdn.h.shtml#driver">driver</A>]-&gt;interface-&gt;writebuf_skb(c-&gt;<A HREF="../includes/isdn.h.shtml#driver">driver</A>, c-&gt;arg, 1, skb) &lt;= 0) {
						dev_kfree_skb(skb);
						<FONT COLOR="#298C52">break</FONT>;
					} <FONT COLOR="#298C52">else</FONT> {
						<FONT COLOR="#298C52">if</FONT> (v-&gt;SyncInit)
							v-&gt;SyncInit--;
						v-&gt;skbidle++;
					}
				} <FONT COLOR="#298C52">else</FONT>
					<FONT COLOR="#298C52">break</FONT>;
			}
			atomic_dec(&amp;dev-&gt;v110use[idx]);
			<FONT COLOR="#298C52">return</FONT> ret;
		<FONT COLOR="#298C52">case</FONT> <A HREF="../includes/isdnif.h.shtml#ISDN_STAT_DHUP">ISDN_STAT_DHUP</A>:
		<FONT COLOR="#298C52">case</FONT> <A HREF="../includes/isdnif.h.shtml#ISDN_STAT_BHUP">ISDN_STAT_BHUP</A>:
			<FONT COLOR="#298C52">while</FONT> (1) {
				atomic_inc(&amp;dev-&gt;v110use[idx]);
				<FONT COLOR="#298C52">if</FONT> (atomic_dec_and_test(&amp;dev-&gt;v110use[idx])) {
					<A HREF="#isdn_v110_close">isdn_v110_close</A>(dev-&gt;v110[idx]);
					dev-&gt;v110[idx] = NULL;
					<FONT COLOR="#298C52">break</FONT>;
				}
				<A HREF="kdebug.h.shtml#sti">sti</A>();
			}
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> <A HREF="../includes/isdnif.h.shtml#ISDN_STAT_BCONN">ISDN_STAT_BCONN</A>:
			<FONT COLOR="#298C52">if</FONT> (dev-&gt;v110emu[idx] &amp;&amp; (dev-&gt;v110[idx] == NULL)) {
				<FONT COLOR="#298C52">int</FONT> hdrlen = dev-&gt;drv[c-&gt;<A HREF="../includes/isdn.h.shtml#driver">driver</A>]-&gt;interface-&gt;hl_hdrlen;
				<FONT COLOR="#298C52">int</FONT> maxsize = dev-&gt;drv[c-&gt;<A HREF="../includes/isdn.h.shtml#driver">driver</A>]-&gt;interface-&gt;maxbufsize;
				atomic_inc(&amp;dev-&gt;v110use[idx]);
				<FONT COLOR="#298C52">switch</FONT> (dev-&gt;v110emu[idx]) {
					<FONT COLOR="#298C52">case</FONT> <A HREF="../includes/isdnif.h.shtml#ISDN_PROTO_L2_V11096">ISDN_PROTO_L2_V11096</A>:
						dev-&gt;v110[idx] = <A HREF="#isdn_v110_open">isdn_v110_open</A>(<A HREF="#V110_9600">V110_9600</A>, hdrlen, maxsize);
						<FONT COLOR="#298C52">break</FONT>;
					<FONT COLOR="#298C52">case</FONT> <A HREF="../includes/isdnif.h.shtml#ISDN_PROTO_L2_V11019">ISDN_PROTO_L2_V11019</A>:
						dev-&gt;v110[idx] = <A HREF="#isdn_v110_open">isdn_v110_open</A>(<A HREF="#V110_19200">V110_19200</A>, hdrlen, maxsize);
						<FONT COLOR="#298C52">break</FONT>;
					<FONT COLOR="#298C52">case</FONT> <A HREF="../includes/isdnif.h.shtml#ISDN_PROTO_L2_V11038">ISDN_PROTO_L2_V11038</A>:
						dev-&gt;v110[idx] = <A HREF="#isdn_v110_open">isdn_v110_open</A>(<A HREF="#V110_38400">V110_38400</A>, hdrlen, maxsize);
						<FONT COLOR="#298C52">break</FONT>;
					<FONT COLOR="#298C52">default</FONT>:
				}
				<FONT COLOR="#298C52">if</FONT> ((v = dev-&gt;v110[idx])) {
					<FONT COLOR="#298C52">while</FONT> (v-&gt;SyncInit) {
						<FONT COLOR="#298C52">struct</FONT> sk_buff *skb = <A HREF="#isdn_v110_sync">isdn_v110_sync</A>(v);
						<FONT COLOR="#298C52">if</FONT> (dev-&gt;drv[c-&gt;<A HREF="../includes/isdn.h.shtml#driver">driver</A>]-&gt;interface-&gt;writebuf_skb(c-&gt;<A HREF="../includes/isdn.h.shtml#driver">driver</A>, c-&gt;arg, 1, skb) &lt;= 0) {
							dev_kfree_skb(skb);
							<FONT COLOR=#0000FF>/* Unable to send, try later */</FONT>
							<FONT COLOR="#298C52">break</FONT>;
						}
						v-&gt;SyncInit--;
						v-&gt;skbidle++;
					}
				} <FONT COLOR="#298C52">else</FONT>
					printk(KERN_WARNING <FONT COLOR="#FF0000">"isdn_v110: Couldn't open stream for chan %d\n"</FONT>, idx);
				atomic_dec(&amp;dev-&gt;v110use[idx]);
			}
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">default</FONT>:
			<FONT COLOR="#298C52">return</FONT> 0;
	}
	<FONT COLOR="#298C52">return</FONT> 0;
}
</BODY>

</HTML>
