<HTML>

<!-- Generated by c2html-1.0, Copyright 1998 by Dave Whittington -->
<HEAD>
<TITLE>isdn_bsdcomp.c</TITLE>
<!--#include virtual="/ssi/js.shtml" -->
<!--#include virtual="/ssi/buttondefs.shtml" -->
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE WIDTH="100%">
<TR>
<TD ALIGN=LEFT WIDTH="90"><!--#include virtual="/ssi/b_home.shtml" --></TD>
<TD ALIGN=RIGHT WIDTH="90"><!--#include virtual="/ssi/b_index.shtml" --></TD>
</TR>
</TABLE>
<CENTER><H1>isdn_bsdcomp.c</H1></CENTER>

<HR>
<PRE>
<FONT COLOR=#0000FF>/*
 * BSD compression module
 *
 * Patched version for ISDN syncPPP written 1997/1998 by Michael Hipp
 * The whole module is now SKB based.
 *
 * Compile with:
 *  gcc -O2 -I/usr/src/linux/include -D__KERNEL__ -DMODULE -c isdn_bsdcomp.c
 */</FONT>

<FONT COLOR=#0000FF>/*
 * Original copyright notice:
 *
 * Copyright (c) 1985, 1986 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * James A. Woods, derived from original work by Spencer Thomas
 * and Joseph Orost.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</FONT>

<FONT COLOR=#A521F7>#ifndef</FONT> MODULE
<FONT COLOR=#A521F7>#error</FONT> This file must be compiled as a module.
<FONT COLOR=#A521F7>#endif</FONT>

<FONT COLOR=#A521F7>#include</FONT> &lt;linux/module.h&gt;

<FONT COLOR=#A521F7>#include</FONT> &lt;linux/kernel.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/sched.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/types.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/fcntl.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/interrupt.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/ptrace.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/ioport.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/in.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/malloc.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/tty.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/errno.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/sched.h&gt;	<FONT COLOR=#0000FF>/* to get the struct task_struct */</FONT>
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/string.h&gt;	<FONT COLOR=#0000FF>/* used in new tty drivers */</FONT>
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/signal.h&gt;	<FONT COLOR=#0000FF>/* used in new tty drivers */</FONT>

<FONT COLOR=#A521F7>#include</FONT> &lt;<FONT COLOR="#298C52">asm</FONT>/system.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;<FONT COLOR="#298C52">asm</FONT>/bitops.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;<FONT COLOR="#298C52">asm</FONT>/segment.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;<FONT COLOR="#298C52">asm</FONT>/byteorder.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;<FONT COLOR="#298C52">asm</FONT>/types.h&gt;

<FONT COLOR=#A521F7>#include</FONT> &lt;linux/<FONT COLOR="#298C52">if</FONT>.h&gt;

<FONT COLOR=#A521F7>#include</FONT> &lt;linux/if_ether.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/netdevice.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/skbuff.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/inet.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/ioctl.h&gt;

<FONT COLOR=#A521F7>#include</FONT> &lt;linux/ppp_defs.h&gt;

<FONT COLOR=#A521F7>#include</FONT> &lt;linux/isdn.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/isdn_ppp.h&gt;
<FONT COLOR=#0000FF>/* #include &lt;linux/netprotocol.h&gt; */</FONT>
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/ip.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/tcp.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/if_arp.h&gt;
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/ppp-comp.h&gt;

<FONT COLOR=#A521F7>#include</FONT> <FONT COLOR="#FF0000">"isdn_ppp.h"</FONT>

<FONT COLOR=#A521F7>#define</FONT> <A NAME="BSD_VERSION">BSD_VERSION</A>(x)	((x) &gt;&gt; 5)
<FONT COLOR=#A521F7>#define</FONT> <A NAME="BSD_NBITS">BSD_NBITS</A>(x)	((x) &amp; 0x1F)

<FONT COLOR=#A521F7>#define</FONT> <A NAME="BSD_CURRENT_VERSION">BSD_CURRENT_VERSION</A>	1

<FONT COLOR=#A521F7>#define</FONT> <A NAME="DEBUG">DEBUG</A> 1

<FONT COLOR=#0000FF>/*
 * A dictionary for doing BSD compress.
 */</FONT>

<FONT COLOR="#298C52">struct</FONT> bsd_dict {
	u32 fcode;
	u16 codem1;		<FONT COLOR=#0000FF>/* output of hash table -1 */</FONT>
	u16 cptr;		<FONT COLOR=#0000FF>/* map code to hash table entry */</FONT>
};

<FONT COLOR="#298C52">struct</FONT> bsd_db {
	<FONT COLOR="#298C52">int</FONT>            totlen;		<FONT COLOR=#0000FF>/* length of this structure */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   hsize;		<FONT COLOR=#0000FF>/* size of the hash table */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT>  hshift;		<FONT COLOR=#0000FF>/* used in hash function */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT>  n_bits;		<FONT COLOR=#0000FF>/* current bits/code */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT>  maxbits;		<FONT COLOR=#0000FF>/* maximum bits/code */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT>  debug;		<FONT COLOR=#0000FF>/* non-zero if debug desired */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT>  unit;		<FONT COLOR=#0000FF>/* ppp unit number */</FONT>
	u16 seqno;          		<FONT COLOR=#0000FF>/* sequence # of next packet */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   mru;		<FONT COLOR=#0000FF>/* size of receive (decompress) bufr */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   maxmaxcode;	<FONT COLOR=#0000FF>/* largest valid code */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   max_ent;		<FONT COLOR=#0000FF>/* largest code in use */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   in_count;	<FONT COLOR=#0000FF>/* uncompressed bytes, aged */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   bytes_out;	<FONT COLOR=#0000FF>/* compressed bytes, aged */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   ratio;		<FONT COLOR=#0000FF>/* recent compression ratio */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   checkpoint;	<FONT COLOR=#0000FF>/* when to next check the ratio */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   clear_count;	<FONT COLOR=#0000FF>/* times dictionary cleared */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   incomp_count;	<FONT COLOR=#0000FF>/* incompressible packets */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   incomp_bytes;	<FONT COLOR=#0000FF>/* incompressible bytes */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   uncomp_count;	<FONT COLOR=#0000FF>/* uncompressed packets */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   uncomp_bytes;	<FONT COLOR=#0000FF>/* uncompressed bytes */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   comp_count;	<FONT COLOR=#0000FF>/* compressed packets */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>   comp_bytes;	<FONT COLOR=#0000FF>/* compressed bytes */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">short</FONT>  *lens;		<FONT COLOR=#0000FF>/* array of lengths of codes */</FONT>
	<FONT COLOR="#298C52">struct</FONT> bsd_dict *dict;		<FONT COLOR=#0000FF>/* dictionary */</FONT>
	<FONT COLOR="#298C52">int</FONT> xmit;
};

<FONT COLOR=#A521F7>#define</FONT> <A NAME="BSD_OVHD">BSD_OVHD</A>	2		<FONT COLOR=#0000FF>/* BSD compress overhead/packet */</FONT>
<FONT COLOR=#A521F7>#define</FONT> <A NAME="MIN_BSD_BITS">MIN_BSD_BITS</A>	9
<FONT COLOR=#A521F7>#define</FONT> <A NAME="BSD_INIT_BITS">BSD_INIT_BITS</A>	<A HREF="#MIN_BSD_BITS">MIN_BSD_BITS</A>
<FONT COLOR=#A521F7>#define</FONT> <A NAME="MAX_BSD_BITS">MAX_BSD_BITS</A>	15

<FONT COLOR=#0000FF>/*
 * the next two codes should not be changed lightly, as they must not
 * lie within the contiguous general code space.
 */</FONT>
<FONT COLOR=#A521F7>#define</FONT> <A NAME="CLEAR">CLEAR</A>	256			<FONT COLOR=#0000FF>/* table clear output code */</FONT>
<FONT COLOR=#A521F7>#define</FONT> <A NAME="FIRST">FIRST</A>	257			<FONT COLOR=#0000FF>/* first free entry */</FONT>
<FONT COLOR=#A521F7>#define</FONT> <A NAME="LAST">LAST</A>	255

<FONT COLOR=#A521F7>#define</FONT> <A NAME="MAXCODE">MAXCODE</A>(b)	((1 &lt;&lt; (b)) - 1)
<FONT COLOR=#A521F7>#define</FONT> <A NAME="BADCODEM1">BADCODEM1</A>	<A HREF="#MAXCODE">MAXCODE</A>(<A HREF="#MAX_BSD_BITS">MAX_BSD_BITS</A>);

<FONT COLOR=#A521F7>#define</FONT> <A HREF="#BSD_HASH">BSD_HASH</A>(prefix,suffix,hshift) ((((<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">long</FONT>)(suffix))&lt;&lt;(hshift)) \
					 ^ (<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">long</FONT>)(prefix))
<FONT COLOR=#A521F7>#define</FONT> <A HREF="#BSD_KEY">BSD_KEY</A>(prefix,suffix)		((((<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">long</FONT>)(suffix)) &lt;&lt; 16) \
					 + (<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">long</FONT>)(prefix))

<FONT COLOR=#A521F7>#define</FONT> <A NAME="CHECK_GAP">CHECK_GAP</A>	10000		<FONT COLOR=#0000FF>/* Ratio check interval */</FONT>

<FONT COLOR=#A521F7>#define</FONT> <A NAME="RATIO_SCALE_LOG">RATIO_SCALE_LOG</A>	8
<FONT COLOR=#A521F7>#define</FONT> <A NAME="RATIO_SCALE">RATIO_SCALE</A>	(1&lt;&lt;<A HREF="#RATIO_SCALE_LOG">RATIO_SCALE_LOG</A>)
<FONT COLOR=#A521F7>#define</FONT> <A NAME="RATIO_MAX">RATIO_MAX</A>	(0x7fffffff&gt;&gt;<A HREF="#RATIO_SCALE_LOG">RATIO_SCALE_LOG</A>)

<FONT COLOR=#0000FF>/*
 * clear the dictionary
 */</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT> <A NAME="bsd_clear">bsd_clear</A>(<FONT COLOR="#298C52">struct</FONT> bsd_db *db)
{
	db-&gt;clear_count++;
	db-&gt;max_ent      = <A HREF="#FIRST">FIRST</A>-1;
	db-&gt;n_bits       = <A HREF="#BSD_INIT_BITS">BSD_INIT_BITS</A>;
	db-&gt;bytes_out    = 0;
	db-&gt;in_count     = 0;
	db-&gt;incomp_count = 0;
	db-&gt;ratio	     = 0;
	db-&gt;checkpoint   = <A HREF="#CHECK_GAP">CHECK_GAP</A>;
}

<FONT COLOR=#0000FF>/*
 * If the dictionary is full, then see if it is time to reset it.
 *
 * Compute the compression ratio using fixed-point arithmetic
 * with 8 fractional bits.
 *
 * Since we have an infinite stream instead of a single file,
 * watch only the local compression ratio.
 *
 * Since both peers must reset the dictionary at the same time even in
 * the absence of CLEAR codes (while packets are incompressible), they
 * must compute the same ratio.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">int</FONT> <A HREF="#bsd_check">bsd_check</A> (<FONT COLOR="#298C52">struct</FONT> bsd_db *db)	<FONT COLOR=#0000FF>/* 1=output CLEAR */</FONT>
{
    <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> new_ratio;

    <FONT COLOR="#298C52">if</FONT> (db-&gt;in_count &gt;= db-&gt;checkpoint)
      {
	<FONT COLOR=#0000FF>/* age the ratio by limiting the size of the counts */</FONT>
	<FONT COLOR="#298C52">if</FONT> (db-&gt;in_count &gt;= <A HREF="#RATIO_MAX">RATIO_MAX</A> || db-&gt;bytes_out &gt;= <A HREF="#RATIO_MAX">RATIO_MAX</A>)
	  {
	    db-&gt;in_count  -= (db-&gt;in_count  &gt;&gt; 2);
	    db-&gt;bytes_out -= (db-&gt;bytes_out &gt;&gt; 2);
	  }
	
	db-&gt;checkpoint = db-&gt;in_count + <A HREF="#CHECK_GAP">CHECK_GAP</A>;
	
	<FONT COLOR="#298C52">if</FONT> (db-&gt;max_ent &gt;= db-&gt;maxmaxcode)
	  {
	    <FONT COLOR=#0000FF>/* Reset the dictionary only if the ratio is worse,
	     * or if it looks as if it has been poisoned
	     * by incompressible data.
	     *
	     * This does not overflow, because
	     *	db-&gt;in_count &lt;= RATIO_MAX.
	     */</FONT>

	    new_ratio = db-&gt;in_count &lt;&lt; <A HREF="#RATIO_SCALE_LOG">RATIO_SCALE_LOG</A>;
	    <FONT COLOR="#298C52">if</FONT> (db-&gt;bytes_out != 0)
	      {
		new_ratio /= db-&gt;bytes_out;
	      }
	    
	    <FONT COLOR="#298C52">if</FONT> (new_ratio &lt; db-&gt;ratio || new_ratio &lt; 1 * <A HREF="#RATIO_SCALE">RATIO_SCALE</A>)
	      {
		<A HREF="#bsd_clear">bsd_clear</A> (db);
		<FONT COLOR="#298C52">return</FONT> 1;
	      }
	    db-&gt;ratio = new_ratio;
	  }
      }
    <FONT COLOR="#298C52">return</FONT> 0;
}

<FONT COLOR=#0000FF>/*
 * Return statistics.
 */</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT> <A HREF="#bsd_stats">bsd_stats</A> (<FONT COLOR="#298C52">void</FONT> *state, <FONT COLOR="#298C52">struct</FONT> compstat *stats)
{
	<FONT COLOR="#298C52">struct</FONT> bsd_db *db = (<FONT COLOR="#298C52">struct</FONT> bsd_db *) state;
    
	stats-&gt;unc_bytes    = db-&gt;uncomp_bytes;
	stats-&gt;unc_packets  = db-&gt;uncomp_count;
	stats-&gt;comp_bytes   = db-&gt;comp_bytes;
	stats-&gt;comp_packets = db-&gt;comp_count;
	stats-&gt;inc_bytes    = db-&gt;incomp_bytes;
	stats-&gt;inc_packets  = db-&gt;incomp_count;
	stats-&gt;in_count     = db-&gt;in_count;
	stats-&gt;bytes_out    = db-&gt;bytes_out;
}

<FONT COLOR=#0000FF>/*
 * Reset state, as on a CCP ResetReq.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT> <A NAME="bsd_reset">bsd_reset</A> (<FONT COLOR="#298C52">void</FONT> *state)
{
	<FONT COLOR="#298C52">struct</FONT> bsd_db *db = (<FONT COLOR="#298C52">struct</FONT> bsd_db *) state;

	<A HREF="#bsd_clear">bsd_clear</A>(db);
	db-&gt;seqno       = 0;
	db-&gt;clear_count = 0;
}

<FONT COLOR=#0000FF>/*
 * Release the compression structure
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT> <A NAME="bsd_free">bsd_free</A> (<FONT COLOR="#298C52">void</FONT> *state)
{
	<FONT COLOR="#298C52">struct</FONT> bsd_db *db = (<FONT COLOR="#298C52">struct</FONT> bsd_db *) state;

	<FONT COLOR="#298C52">if</FONT> (db) {
		<FONT COLOR=#0000FF>/*
		 * Release the dictionary
		 */</FONT>
		<FONT COLOR="#298C52">if</FONT> (db-&gt;dict) {
			vfree (db-&gt;dict);
			db-&gt;dict = NULL;
		}

		<FONT COLOR=#0000FF>/*
		 * Release the string buffer
		 */</FONT>
		<FONT COLOR="#298C52">if</FONT> (db-&gt;lens) {
			vfree (db-&gt;lens);
			db-&gt;lens = NULL;
		}

		<FONT COLOR=#0000FF>/*
		 * Finally release the structure itself.
		 */</FONT>
		kfree (db);
		MOD_DEC_USE_COUNT;
	}
}


<FONT COLOR=#0000FF>/*
 * Allocate space for a (de) compressor.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT> *<A HREF="#bsd_alloc">bsd_alloc</A> (<FONT COLOR="#298C52">struct</FONT> isdn_ppp_comp_data *data)
{
	<FONT COLOR="#298C52">int</FONT> bits;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> hsize, hshift, maxmaxcode;
	<FONT COLOR="#298C52">struct</FONT> bsd_db *db;
	<FONT COLOR="#298C52">int</FONT> decomp;

	<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> htab[][2] = {
		{ 5003 , 4 } , { 5003 , 4 } , { 5003 , 4 } , { 5003 , 4 } , 
		{ 9001 , 5 } , { 18013 , 6 } , { 35023 , 7 } , { 69001 , 8 } 
	};
		
	<FONT COLOR="#298C52">if</FONT> (data-&gt;optlen != 1 || data-&gt;num != CI_BSD_COMPRESS
		|| <A HREF="#BSD_VERSION">BSD_VERSION</A>(data-&gt;options[0]) != <A HREF="#BSD_CURRENT_VERSION">BSD_CURRENT_VERSION</A>)
		<FONT COLOR="#298C52">return</FONT> NULL;

	bits = <A HREF="#BSD_NBITS">BSD_NBITS</A>(data-&gt;options[0]);

	<FONT COLOR="#298C52">if</FONT>(bits &lt; 9 || bits &gt; 15)
		<FONT COLOR="#298C52">return</FONT> NULL;

	hsize = htab[bits-9][0];
	hshift = htab[bits-9][1];
	
	<FONT COLOR=#0000FF>/*
	 * Allocate the main control structure for this instance.
	 */</FONT>
	maxmaxcode = <A HREF="#MAXCODE">MAXCODE</A>(bits);
	db = (<FONT COLOR="#298C52">struct</FONT> bsd_db *) kmalloc (<FONT COLOR="#298C52">sizeof</FONT> (<FONT COLOR="#298C52">struct</FONT> bsd_db),GFP_KERNEL);
	<FONT COLOR="#298C52">if</FONT> (!db)
		<FONT COLOR="#298C52">return</FONT> NULL;

	memset (db, 0, <FONT COLOR="#298C52">sizeof</FONT>(<FONT COLOR="#298C52">struct</FONT> bsd_db));

	db-&gt;xmit = data-&gt;flags &amp; <A HREF="../includes/isdn_ppp.h.shtml#IPPP_COMP_FLAG_XMIT">IPPP_COMP_FLAG_XMIT</A>;
	decomp = db-&gt;xmit ? 0 : 1;

	<FONT COLOR=#0000FF>/*
	 * Allocate space for the dictionary. This may be more than one page in
	 * length.
	 */</FONT>
	db-&gt;dict = (<FONT COLOR="#298C52">struct</FONT> bsd_dict *) vmalloc (hsize * <FONT COLOR="#298C52">sizeof</FONT> (<FONT COLOR="#298C52">struct</FONT> bsd_dict));
	<FONT COLOR="#298C52">if</FONT> (!db-&gt;dict) {
		<A HREF="#bsd_free">bsd_free</A> (db);
		<FONT COLOR="#298C52">return</FONT> NULL;
	}

	MOD_INC_USE_COUNT;

	<FONT COLOR=#0000FF>/*
	 * If this is the compression buffer then there is no length data.
	 * For decompression, the length information is needed as well.
	 */</FONT>
	<FONT COLOR="#298C52">if</FONT> (!decomp)
		db-&gt;lens = NULL;
	<FONT COLOR="#298C52">else</FONT> {
		db-&gt;lens = (<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">short</FONT> *) vmalloc ((maxmaxcode + 1) *
			<FONT COLOR="#298C52">sizeof</FONT> (db-&gt;lens[0]));
		<FONT COLOR="#298C52">if</FONT> (!db-&gt;lens) {
			<A HREF="#bsd_free">bsd_free</A> (db); <FONT COLOR=#0000FF>/* calls MOD_DEC_USE_COUNT; */</FONT>
			<FONT COLOR="#298C52">return</FONT> (NULL);
		}
	}

	<FONT COLOR=#0000FF>/*
	 * Initialize the data information for the compression code
	 */</FONT>
	db-&gt;totlen     = <FONT COLOR="#298C52">sizeof</FONT> (<FONT COLOR="#298C52">struct</FONT> bsd_db) + (<FONT COLOR="#298C52">sizeof</FONT> (<FONT COLOR="#298C52">struct</FONT> bsd_dict) * hsize);
	db-&gt;hsize      = hsize;
	db-&gt;hshift     = hshift;
	db-&gt;maxmaxcode = maxmaxcode;
	db-&gt;maxbits    = bits;

	<FONT COLOR="#298C52">return</FONT> (<FONT COLOR="#298C52">void</FONT> *) db;
}

<FONT COLOR=#0000FF>/*
 * Initialize the database.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">int</FONT> <A HREF="#bsd_init">bsd_init</A> (<FONT COLOR="#298C52">void</FONT> *state, <FONT COLOR="#298C52">struct</FONT> isdn_ppp_comp_data *data, <FONT COLOR="#298C52">int</FONT> unit, <FONT COLOR="#298C52">int</FONT> debug)
{
	<FONT COLOR="#298C52">struct</FONT> bsd_db *db = state;
	<FONT COLOR="#298C52">int</FONT> indx;
	<FONT COLOR="#298C52">int</FONT> decomp;

	<FONT COLOR="#298C52">if</FONT>(!state || !data) {
		printk(KERN_ERR <FONT COLOR="#FF0000">"isdn_bsd_init: [%d] ERR, state %lx data %lx\n"</FONT>,unit,(<FONT COLOR="#298C52">long</FONT>)state,(<FONT COLOR="#298C52">long</FONT>)data);
		<FONT COLOR="#298C52">return</FONT> 0;
	}

	decomp = db-&gt;xmit ? 0 : 1;
    
	<FONT COLOR="#298C52">if</FONT> (data-&gt;optlen != 1 || data-&gt;num != CI_BSD_COMPRESS
		|| (<A HREF="#BSD_VERSION">BSD_VERSION</A>(data-&gt;options[0]) != <A HREF="#BSD_CURRENT_VERSION">BSD_CURRENT_VERSION</A>)
		|| (<A HREF="#BSD_NBITS">BSD_NBITS</A>(data-&gt;options[0]) != db-&gt;maxbits)
		|| (decomp &amp;&amp; db-&gt;lens == NULL)) {
		printk(KERN_ERR <FONT COLOR="#FF0000">"isdn_bsd: %d %d %d %d %lx\n"</FONT>,data-&gt;optlen,data-&gt;num,data-&gt;options[0],decomp,(<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">long</FONT>)db-&gt;lens);
		<FONT COLOR="#298C52">return</FONT> 0;
	}

	<FONT COLOR="#298C52">if</FONT> (decomp)
		<FONT COLOR="#298C52">for</FONT>(indx=<A HREF="#LAST">LAST</A>;indx&gt;=0;indx--)
			db-&gt;lens[indx] = 1;

	indx = db-&gt;hsize;
	<FONT COLOR="#298C52">while</FONT> (indx-- != 0) {
		db-&gt;dict[indx].codem1 = <A HREF="#BADCODEM1">BADCODEM1</A>;
		db-&gt;dict[indx].cptr   = 0;
	}

	db-&gt;unit = unit;
	db-&gt;mru  = 0;

	db-&gt;debug = 1;
    
	<A HREF="#bsd_reset">bsd_reset</A>(db);
    
	<FONT COLOR="#298C52">return</FONT> 1;
}

<FONT COLOR=#0000FF>/*
 * Obtain pointers to the various structures in the compression tables
 */</FONT>

<FONT COLOR=#A521F7>#define</FONT> <A NAME="dict_ptrx">dict_ptrx</A>(p,idx) &amp;(p-&gt;dict[idx])
<FONT COLOR=#A521F7>#define</FONT> <A NAME="lens_ptrx">lens_ptrx</A>(p,idx) &amp;(p-&gt;lens[idx])

<FONT COLOR=#A521F7>#ifdef</FONT> <A HREF="#DEBUG">DEBUG</A>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">short</FONT> *<A HREF="#lens_ptr">lens_ptr</A>(<FONT COLOR="#298C52">struct</FONT> bsd_db *db, <FONT COLOR="#298C52">int</FONT> idx)
{
	<FONT COLOR="#298C52">if</FONT> ((<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>) idx &gt; (<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>) db-&gt;maxmaxcode) {
		printk (KERN_DEBUG <FONT COLOR="#FF0000">"&lt;9&gt;ppp: lens_ptr(%d) &gt; max\n"</FONT>, idx);
		idx = 0;
	}
	<FONT COLOR="#298C52">return</FONT> <A HREF="#lens_ptrx">lens_ptrx</A> (db, idx);
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">struct</FONT> bsd_dict *<A HREF="#dict_ptr">dict_ptr</A>(<FONT COLOR="#298C52">struct</FONT> bsd_db *db, <FONT COLOR="#298C52">int</FONT> idx)
{
	<FONT COLOR="#298C52">if</FONT> ((<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>) idx &gt;= (<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT>) db-&gt;hsize) {
		printk (KERN_DEBUG <FONT COLOR="#FF0000">"&lt;9&gt;ppp: dict_ptr(%d) &gt; max\n"</FONT>, idx);
		idx = 0;
	}
	<FONT COLOR="#298C52">return</FONT> <A HREF="#dict_ptrx">dict_ptrx</A> (db, idx);
}

<FONT COLOR=#A521F7>#else</FONT>
<FONT COLOR=#A521F7>#define</FONT> <A HREF="#lens_ptr">lens_ptr</A>(db,idx) <A HREF="#lens_ptrx">lens_ptrx</A>(db,idx)
<FONT COLOR=#A521F7>#define</FONT> <A HREF="#dict_ptr">dict_ptr</A>(db,idx) <A HREF="#dict_ptrx">dict_ptrx</A>(db,idx)
<FONT COLOR=#A521F7>#endif</FONT>

<FONT COLOR=#0000FF>/*
 * compress a packet
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">int</FONT> <A HREF="#bsd_compress">bsd_compress</A> (<FONT COLOR="#298C52">void</FONT> *state, <FONT COLOR="#298C52">struct</FONT> sk_buff *skb_in, <FONT COLOR="#298C52">struct</FONT> sk_buff *skb_out,<FONT COLOR="#298C52">int</FONT> proto)
{
	<FONT COLOR="#298C52">struct</FONT> bsd_db *db;
	<FONT COLOR="#298C52">int</FONT> hshift;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> max_ent;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> n_bits;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> bitno;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">long</FONT> accm;
	<FONT COLOR="#298C52">int</FONT> ent;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">long</FONT> fcode;
	<FONT COLOR="#298C52">struct</FONT> bsd_dict *dictp;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> c;
	<FONT COLOR="#298C52">int</FONT> hval,disp,ilen,mxcode;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *rptr = skb_in-&gt;data;
	<FONT COLOR="#298C52">int</FONT> isize = skb_in-&gt;len;

<FONT COLOR=#A521F7>#define</FONT> <A HREF="#OUTPUT">OUTPUT</A>(ent)			\
  {					\
    bitno -= n_bits;			\
    accm |= ((ent) &lt;&lt; bitno);		\
    <FONT COLOR="#298C52">do</FONT>	{				\
        <FONT COLOR="#298C52">if</FONT>(skb_out &amp;&amp; skb_tailroom(skb_out) &gt; 0) 	\
      		*(skb_put(skb_out,1)) = (<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT>) (accm&gt;&gt;24); \
	accm &lt;&lt;= 8;			\
	bitno += 8;			\
    } <FONT COLOR="#298C52">while</FONT> (bitno &lt;= 24);		\
  }

	<FONT COLOR=#0000FF>/*
	 * If the protocol is not in the range we're interested in,
	 * just return without compressing the packet.  If it is,
	 * the protocol becomes the first byte to compress.
	 */</FONT>
	printk(KERN_DEBUG <FONT COLOR="#FF0000">"bsd_compress called with %x\n"</FONT>,proto);
	
	ent = proto;
	<FONT COLOR="#298C52">if</FONT> (proto &lt; 0x21 || proto &gt; 0xf9 || !(proto &amp; 0x1) )
		<FONT COLOR="#298C52">return</FONT> 0;

	db      = (<FONT COLOR="#298C52">struct</FONT> bsd_db *) state;
	hshift  = db-&gt;hshift;
	max_ent = db-&gt;max_ent;
	n_bits  = db-&gt;n_bits;
	bitno   = 32;
	accm    = 0;
	mxcode  = <A HREF="#MAXCODE">MAXCODE</A> (n_bits);
	
	<FONT COLOR=#0000FF>/* This is the PPP header information */</FONT>
	<FONT COLOR="#298C52">if</FONT>(skb_out &amp;&amp; skb_tailroom(skb_out) &gt;= 2) {
		<FONT COLOR="#298C52">char</FONT> *v = skb_put(skb_out,2);
		<FONT COLOR=#0000FF>/* we only push our own data on the header,
		  AC,PC and protos is pushed by caller  */</FONT>
		v[0] = db-&gt;seqno &gt;&gt; 8;
		v[1] = db-&gt;seqno;
	}

	ilen   = ++isize; <FONT COLOR=#0000FF>/* This is off by one, but that is what is in draft! */</FONT>

	<FONT COLOR="#298C52">while</FONT> (--ilen &gt; 0) {
		c     = *rptr++;
		fcode = <A HREF="#BSD_KEY">BSD_KEY</A>  (ent, c);
		hval  = <A HREF="#BSD_HASH">BSD_HASH</A> (ent, c, hshift);
		dictp = <A HREF="#dict_ptr">dict_ptr</A> (db, hval);
	
		<FONT COLOR=#0000FF>/* Validate and then check the entry. */</FONT>
		<FONT COLOR="#298C52">if</FONT> (dictp-&gt;codem1 &gt;= max_ent)
			<FONT COLOR="#298C52">goto</FONT> nomatch;

		<FONT COLOR="#298C52">if</FONT> (dictp-&gt;fcode == fcode) {
			ent = dictp-&gt;codem1 + 1;
			<FONT COLOR="#298C52">continue</FONT>;	<FONT COLOR=#0000FF>/* found (prefix,suffix) */</FONT>
		}
	
		<FONT COLOR=#0000FF>/* continue probing until a match or invalid entry */</FONT>
		disp = (hval == 0) ? 1 : hval;

		<FONT COLOR="#298C52">do</FONT> {
			hval += disp;
			<FONT COLOR="#298C52">if</FONT> (hval &gt;= db-&gt;hsize)
				hval -= db-&gt;hsize;
			dictp = <A HREF="#dict_ptr">dict_ptr</A> (db, hval);
			<FONT COLOR="#298C52">if</FONT> (dictp-&gt;codem1 &gt;= max_ent)
				<FONT COLOR="#298C52">goto</FONT> nomatch;
		} <FONT COLOR="#298C52">while</FONT> (dictp-&gt;fcode != fcode);

		ent = dictp-&gt;codem1 + 1;	<FONT COLOR=#0000FF>/* finally found (prefix,suffix) */</FONT>
		<FONT COLOR="#298C52">continue</FONT>;
	
nomatch:
		<A HREF="#OUTPUT">OUTPUT</A>(ent);		<FONT COLOR=#0000FF>/* output the prefix */</FONT>
	
		<FONT COLOR=#0000FF>/* code -&gt; hashtable */</FONT>
		<FONT COLOR="#298C52">if</FONT> (max_ent &lt; db-&gt;maxmaxcode) {
			<FONT COLOR="#298C52">struct</FONT> bsd_dict *dictp2;
			<FONT COLOR="#298C52">struct</FONT> bsd_dict *dictp3;
			<FONT COLOR="#298C52">int</FONT> indx;

			<FONT COLOR=#0000FF>/* expand code size if needed */</FONT>
			<FONT COLOR="#298C52">if</FONT> (max_ent &gt;= mxcode) {
				db-&gt;n_bits = ++n_bits;
				mxcode = <A HREF="#MAXCODE">MAXCODE</A> (n_bits);
			}
	    
			<FONT COLOR=#0000FF>/* 
			 * Invalidate old hash table entry using
			 * this code, and then take it over.
			 */</FONT>
			dictp2 = <A HREF="#dict_ptr">dict_ptr</A> (db, max_ent + 1);
			indx   = dictp2-&gt;cptr;
			dictp3 = <A HREF="#dict_ptr">dict_ptr</A> (db, indx);

			<FONT COLOR="#298C52">if</FONT> (dictp3-&gt;codem1 == max_ent)
				dictp3-&gt;codem1 = <A HREF="#BADCODEM1">BADCODEM1</A>;

			dictp2-&gt;cptr   = hval;
			dictp-&gt;codem1  = max_ent;
			dictp-&gt;fcode = fcode;
			db-&gt;max_ent    = ++max_ent;

			<FONT COLOR="#298C52">if</FONT> (db-&gt;lens) {
				<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">short</FONT> *len1 = <A HREF="#lens_ptr">lens_ptr</A> (db, max_ent);
				<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">short</FONT> *len2 = <A HREF="#lens_ptr">lens_ptr</A> (db, ent);
				*len1 = *len2 + 1;
			}
		}
		ent = c;
	}
    
	<A HREF="#OUTPUT">OUTPUT</A>(ent);		<FONT COLOR=#0000FF>/* output the last code */</FONT>

	<FONT COLOR="#298C52">if</FONT>(skb_out)
		db-&gt;bytes_out    += skb_out-&gt;len; <FONT COLOR=#0000FF>/* Do not count bytes from here */</FONT>
	db-&gt;uncomp_bytes += isize;
	db-&gt;in_count     += isize;
	++db-&gt;uncomp_count;
	++db-&gt;seqno;

	<FONT COLOR="#298C52">if</FONT> (bitno &lt; 32)
		++db-&gt;bytes_out; <FONT COLOR=#0000FF>/* must be set before calling bsd_check */</FONT>

	<FONT COLOR=#0000FF>/*
	 * Generate the clear command if needed
	 */</FONT>

	<FONT COLOR="#298C52">if</FONT> (<A HREF="#bsd_check">bsd_check</A>(db))
		<A HREF="#OUTPUT">OUTPUT</A> (<A HREF="#CLEAR">CLEAR</A>);

	<FONT COLOR=#0000FF>/*
	 * Pad dribble bits of last code with ones.
	 * Do not emit a completely useless byte of ones.
	 */</FONT>
	<FONT COLOR="#298C52">if</FONT> (bitno &lt; 32 &amp;&amp; skb_out &amp;&amp; skb_tailroom(skb_out) &gt; 0) 
		*(skb_put(skb_out,1)) = (<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT>) ((accm | (0xff &lt;&lt; (bitno-8))) &gt;&gt; 24);
    
	<FONT COLOR=#0000FF>/*
	 * Increase code size if we would have without the packet
	 * boundary because the decompressor will do so.
	 */</FONT>
	<FONT COLOR="#298C52">if</FONT> (max_ent &gt;= mxcode &amp;&amp; max_ent &lt; db-&gt;maxmaxcode)
		db-&gt;n_bits++;

	<FONT COLOR=#0000FF>/* If output length is too large then this is an incompressible frame. */</FONT>
	<FONT COLOR="#298C52">if</FONT> (!skb_out || (skb_out &amp;&amp; skb_out-&gt;len &gt;= skb_in-&gt;len) ) {
		++db-&gt;incomp_count;
		db-&gt;incomp_bytes += isize;
		<FONT COLOR="#298C52">return</FONT> 0;
	}

	<FONT COLOR=#0000FF>/* Count the number of compressed frames */</FONT>
	++db-&gt;comp_count;
	db-&gt;comp_bytes += skb_out-&gt;len;
	<FONT COLOR="#298C52">return</FONT> skb_out-&gt;len;

<FONT COLOR=#A521F7>#undef</FONT> <A HREF="#OUTPUT">OUTPUT</A>
}

<FONT COLOR=#0000FF>/*
 * Update the "BSD Compress" dictionary on the receiver for
 * incompressible data by pretending to compress the incoming data.
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT> <A HREF="#bsd_incomp">bsd_incomp</A> (<FONT COLOR="#298C52">void</FONT> *state, <FONT COLOR="#298C52">struct</FONT> sk_buff *skb_in,<FONT COLOR="#298C52">int</FONT> proto)
{
	<A HREF="#bsd_compress">bsd_compress</A> (state, skb_in, NULL, proto);
}

<FONT COLOR=#0000FF>/*
 * Decompress "BSD Compress".
 */</FONT>
<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">int</FONT> <A HREF="#bsd_decompress">bsd_decompress</A> (<FONT COLOR="#298C52">void</FONT> *state, <FONT COLOR="#298C52">struct</FONT> sk_buff *skb_in, <FONT COLOR="#298C52">struct</FONT> sk_buff *skb_out)
{
	<FONT COLOR="#298C52">struct</FONT> bsd_db *db;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> max_ent;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">long</FONT> accm;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> bitno;		<FONT COLOR=#0000FF>/* 1st valid bit in accm */</FONT>
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> n_bits;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> tgtbitno;	<FONT COLOR=#0000FF>/* bitno when we have a code */</FONT>
	<FONT COLOR="#298C52">struct</FONT> bsd_dict *dictp;
	<FONT COLOR="#298C52">int</FONT> seq;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> incode;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> oldcode;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> finchar;
	<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">char</FONT> *p,*ibuf;
	<FONT COLOR="#298C52">int</FONT> ilen;
	<FONT COLOR="#298C52">int</FONT> codelen;
	<FONT COLOR="#298C52">int</FONT> extra;

	db       = (<FONT COLOR="#298C52">struct</FONT> bsd_db *) state;
	max_ent  = db-&gt;max_ent;
	accm     = 0;
	bitno    = 32;		<FONT COLOR=#0000FF>/* 1st valid bit in accm */</FONT>
	n_bits   = db-&gt;n_bits;
	tgtbitno = 32 - n_bits;	<FONT COLOR=#0000FF>/* bitno when we have a code */</FONT>

	printk(KERN_DEBUG <FONT COLOR="#FF0000">"bsd_decompress called\n"</FONT>);

	<FONT COLOR="#298C52">if</FONT>(!skb_in || !skb_out) {
		printk(KERN_ERR <FONT COLOR="#FF0000">"bsd_decompress called with NULL parameter\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT> DECOMP_ERROR;
	}
    
	<FONT COLOR=#0000FF>/*
	 * Get the sequence number.
	 */</FONT>
	<FONT COLOR="#298C52">if</FONT>( (p = skb_pull(skb_in,2)) == NULL) {
		<FONT COLOR="#298C52">return</FONT> DECOMP_ERROR;
	}
	p-=2;
	seq   = (p[0] &lt;&lt; 8) + p[1];
	ilen  = skb_in-&gt;len;
	ibuf = skb_in-&gt;data;

	<FONT COLOR=#0000FF>/*
	 * Check the sequence number and give up if it differs from
	 * the value we're expecting.
	 */</FONT>
	<FONT COLOR="#298C52">if</FONT> (seq != db-&gt;seqno) {
		<FONT COLOR="#298C52">if</FONT> (db-&gt;debug) {
			printk(KERN_DEBUG <FONT COLOR="#FF0000">"bsd_decomp%d: bad sequence # %d, expected %d\n"</FONT>,
				db-&gt;unit, seq, db-&gt;seqno - 1);
		}
		<FONT COLOR="#298C52">return</FONT> DECOMP_ERROR;
	}

	++db-&gt;seqno;
	db-&gt;bytes_out += ilen;

	<FONT COLOR="#298C52">if</FONT>(skb_tailroom(skb_out) &gt; 0)
		*(skb_put(skb_out,1)) = 0;
	<FONT COLOR="#298C52">else</FONT>
		<FONT COLOR="#298C52">return</FONT> <A HREF="../includes/isdn_ppp.h.shtml#DECOMP_ERR_NOMEM">DECOMP_ERR_NOMEM</A>;
    
	oldcode = <A HREF="#CLEAR">CLEAR</A>;

	<FONT COLOR=#0000FF>/*
	 * Keep the checkpoint correctly so that incompressible packets
	 * clear the dictionary at the proper times.
	 */</FONT>

	<FONT COLOR="#298C52">for</FONT> (;;) {
		<FONT COLOR="#298C52">if</FONT> (ilen-- &lt;= 0) {
			db-&gt;in_count += (skb_out-&gt;len - 1); <FONT COLOR=#0000FF>/* don't count the header */</FONT>
			<FONT COLOR="#298C52">break</FONT>;
		}

		<FONT COLOR=#0000FF>/*
		 * Accumulate bytes until we have a complete code.
		 * Then get the next code, relying on the 32-bit,
		 * unsigned accm to mask the result.
		 */</FONT>

		bitno -= 8;
		accm  |= *ibuf++ &lt;&lt; bitno;
		<FONT COLOR="#298C52">if</FONT> (tgtbitno &lt; bitno)
			<FONT COLOR="#298C52">continue</FONT>;

		incode = accm &gt;&gt; tgtbitno;
		accm &lt;&lt;= n_bits;
		bitno += n_bits;

		<FONT COLOR=#0000FF>/*
		 * The dictionary must only be cleared at the end of a packet.
		 */</FONT>
	
		<FONT COLOR="#298C52">if</FONT> (incode == <A HREF="#CLEAR">CLEAR</A>) {
			<FONT COLOR="#298C52">if</FONT> (ilen &gt; 0) {
				<FONT COLOR="#298C52">if</FONT> (db-&gt;debug)
					printk(KERN_DEBUG <FONT COLOR="#FF0000">"bsd_decomp%d: bad CLEAR\n"</FONT>, db-&gt;unit);
				<FONT COLOR="#298C52">return</FONT> DECOMP_FATALERROR;	<FONT COLOR=#0000FF>/* probably a bug */</FONT>
			}
			<A HREF="#bsd_clear">bsd_clear</A>(db);
			<FONT COLOR="#298C52">break</FONT>;
		}

		<FONT COLOR="#298C52">if</FONT> ((incode &gt; max_ent + 2) || (incode &gt; db-&gt;maxmaxcode)
			|| (incode &gt; max_ent &amp;&amp; oldcode == <A HREF="#CLEAR">CLEAR</A>)) {
			<FONT COLOR="#298C52">if</FONT> (db-&gt;debug) {
				printk(KERN_DEBUG <FONT COLOR="#FF0000">"bsd_decomp%d: bad code 0x%x oldcode=0x%x "</FONT>,
					db-&gt;unit, incode, oldcode);
				printk(KERN_DEBUG <FONT COLOR="#FF0000">"max_ent=0x%x skb-&gt;Len=%d seqno=%d\n"</FONT>,
					max_ent, skb_out-&gt;len, db-&gt;seqno);
			}
			<FONT COLOR="#298C52">return</FONT> DECOMP_FATALERROR;	<FONT COLOR=#0000FF>/* probably a bug */</FONT>
		}
	
		<FONT COLOR=#0000FF>/* Special case for KwKwK string. */</FONT>
		<FONT COLOR="#298C52">if</FONT> (incode &gt; max_ent) {
			finchar = oldcode;
			extra   = 1;
		} <FONT COLOR="#298C52">else</FONT> {
			finchar = incode;
			extra   = 0;
		}

		codelen = *(<A HREF="#lens_ptr">lens_ptr</A> (db, finchar));
		<FONT COLOR="#298C52">if</FONT>( skb_tailroom(skb_out) &lt; codelen + extra) {
			<FONT COLOR="#298C52">if</FONT> (db-&gt;debug) {
				printk(KERN_DEBUG <FONT COLOR="#FF0000">"bsd_decomp%d: ran out of mru\n"</FONT>, db-&gt;unit);
<FONT COLOR=#A521F7>#ifdef</FONT> <A HREF="#DEBUG">DEBUG</A>
				printk(KERN_DEBUG <FONT COLOR="#FF0000">"  len=%d, finchar=0x%x, codelen=%d,skblen=%d\n"</FONT>,
					ilen, finchar, codelen, skb_out-&gt;len);
<FONT COLOR=#A521F7>#endif</FONT>
			}
			<FONT COLOR="#298C52">return</FONT> DECOMP_FATALERROR;
		}

		<FONT COLOR=#0000FF>/*
		 * Decode this code and install it in the decompressed buffer.
		 */</FONT>

		p     = skb_put(skb_out,codelen);
		p += codelen;
		<FONT COLOR="#298C52">while</FONT> (finchar &gt; <A HREF="#LAST">LAST</A>) {
			<FONT COLOR="#298C52">struct</FONT> bsd_dict *dictp2 = <A HREF="#dict_ptr">dict_ptr</A> (db, finchar);
	    
			dictp = <A HREF="#dict_ptr">dict_ptr</A> (db, dictp2-&gt;cptr);

<FONT COLOR=#A521F7>#ifdef</FONT> <A HREF="#DEBUG">DEBUG</A>
			<FONT COLOR="#298C52">if</FONT> (--codelen &lt;= 0 || dictp-&gt;codem1 != finchar-1) {
				<FONT COLOR="#298C52">if</FONT> (codelen &lt;= 0) {
					printk(KERN_ERR <FONT COLOR="#FF0000">"bsd_decomp%d: fell off end of chain "</FONT>, db-&gt;unit);
					printk(KERN_ERR <FONT COLOR="#FF0000">"0x%x at 0x%x by 0x%x, max_ent=0x%x\n"</FONT>, incode, finchar, dictp2-&gt;cptr, max_ent);
				} <FONT COLOR="#298C52">else</FONT> {
					<FONT COLOR="#298C52">if</FONT> (dictp-&gt;codem1 != finchar-1) {
						printk(KERN_ERR <FONT COLOR="#FF0000">"bsd_decomp%d: bad code chain 0x%x finchar=0x%x "</FONT>,db-&gt;unit, incode, finchar);
						printk(KERN_ERR <FONT COLOR="#FF0000">"oldcode=0x%x cptr=0x%x codem1=0x%x\n"</FONT>, oldcode, dictp2-&gt;cptr, dictp-&gt;codem1);
					}
				}
				<FONT COLOR="#298C52">return</FONT> DECOMP_FATALERROR;
			}
<FONT COLOR=#A521F7>#endif</FONT>

			{
				u32 fcode = dictp-&gt;fcode;
				*--p    = (fcode &gt;&gt; 16) &amp; 0xff;
				finchar = fcode &amp; 0xffff;
			}
		}
		*--p = finchar;
	
<FONT COLOR=#A521F7>#ifdef</FONT> <A HREF="#DEBUG">DEBUG</A>
		<FONT COLOR="#298C52">if</FONT> (--codelen != 0)
			printk(KERN_ERR <FONT COLOR="#FF0000">"bsd_decomp%d: short by %d after code 0x%x, max_ent=0x%x\n"</FONT>, db-&gt;unit, codelen, incode, max_ent);
<FONT COLOR=#A521F7>#endif</FONT>
	
		<FONT COLOR="#298C52">if</FONT> (extra)		<FONT COLOR=#0000FF>/* the KwKwK case again */</FONT>
			*(skb_put(skb_out,1)) = finchar;
	
		<FONT COLOR=#0000FF>/*
		 * If not first code in a packet, and
		 * if not out of code space, then allocate a new code.
		 *
		 * Keep the hash table correct so it can be used
		 * with uncompressed packets.
		 */</FONT>
		<FONT COLOR="#298C52">if</FONT> (oldcode != <A HREF="#CLEAR">CLEAR</A> &amp;&amp; max_ent &lt; db-&gt;maxmaxcode) {
			<FONT COLOR="#298C52">struct</FONT> bsd_dict *dictp2, *dictp3;
			u16  *lens1,  *lens2;
			<FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">long</FONT> fcode;
			<FONT COLOR="#298C52">int</FONT> hval, disp, indx;
	    
			fcode = <A HREF="#BSD_KEY">BSD_KEY</A>(oldcode,finchar);
			hval  = <A HREF="#BSD_HASH">BSD_HASH</A>(oldcode,finchar,db-&gt;hshift);
			dictp = <A HREF="#dict_ptr">dict_ptr</A> (db, hval);
	    
			<FONT COLOR=#0000FF>/* look for a free hash table entry */</FONT>
			<FONT COLOR="#298C52">if</FONT> (dictp-&gt;codem1 &lt; max_ent) {
				disp = (hval == 0) ? 1 : hval;
				<FONT COLOR="#298C52">do</FONT> {
					hval += disp;
					<FONT COLOR="#298C52">if</FONT> (hval &gt;= db-&gt;hsize)
						hval -= db-&gt;hsize;
					dictp = <A HREF="#dict_ptr">dict_ptr</A> (db, hval);
				} <FONT COLOR="#298C52">while</FONT> (dictp-&gt;codem1 &lt; max_ent);
			}
	    
			<FONT COLOR=#0000FF>/*
			 * Invalidate previous hash table entry
			 * assigned this code, and then take it over
			 */</FONT>

			dictp2 = <A HREF="#dict_ptr">dict_ptr</A> (db, max_ent + 1);
			indx   = dictp2-&gt;cptr;
			dictp3 = <A HREF="#dict_ptr">dict_ptr</A> (db, indx);

			<FONT COLOR="#298C52">if</FONT> (dictp3-&gt;codem1 == max_ent)
				dictp3-&gt;codem1 = <A HREF="#BADCODEM1">BADCODEM1</A>;

			dictp2-&gt;cptr   = hval;
			dictp-&gt;codem1  = max_ent;
			dictp-&gt;fcode = fcode;
			db-&gt;max_ent    = ++max_ent;

			<FONT COLOR=#0000FF>/* Update the length of this string. */</FONT>
			lens1  = <A HREF="#lens_ptr">lens_ptr</A> (db, max_ent);
			lens2  = <A HREF="#lens_ptr">lens_ptr</A> (db, oldcode);
			*lens1 = *lens2 + 1;
	    
			<FONT COLOR=#0000FF>/* Expand code size if needed. */</FONT>
			<FONT COLOR="#298C52">if</FONT> (max_ent &gt;= <A HREF="#MAXCODE">MAXCODE</A>(n_bits) &amp;&amp; max_ent &lt; db-&gt;maxmaxcode) {
				db-&gt;n_bits = ++n_bits;
				tgtbitno   = 32-n_bits;
			}
		}
		oldcode = incode;
	}

	++db-&gt;comp_count;
	++db-&gt;uncomp_count;
	db-&gt;comp_bytes   += skb_in-&gt;len - <A HREF="#BSD_OVHD">BSD_OVHD</A>;
	db-&gt;uncomp_bytes += skb_out-&gt;len;

	<FONT COLOR="#298C52">if</FONT> (<A HREF="#bsd_check">bsd_check</A>(db)) {
		<FONT COLOR="#298C52">if</FONT> (db-&gt;debug)
			printk(KERN_DEBUG <FONT COLOR="#FF0000">"bsd_decomp%d: peer should have cleared dictionary on %d\n"</FONT>,
				db-&gt;unit, db-&gt;seqno - 1);
	}
	<FONT COLOR="#298C52">return</FONT> skb_out-&gt;len;
}

<FONT COLOR=#0000FF>/*************************************************************
 * Table of addresses for the BSD compression module
 *************************************************************/</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">struct</FONT> isdn_ppp_compressor ippp_bsd_compress = {
	NULL,NULL,		<FONT COLOR=#0000FF>/* prev,next: overwritten by isdn_ppp */</FONT>
	CI_BSD_COMPRESS,	<FONT COLOR=#0000FF>/* compress_proto */</FONT>
	<A HREF="#bsd_alloc">bsd_alloc</A>,		<FONT COLOR=#0000FF>/* alloc */</FONT>
	<A HREF="#bsd_free">bsd_free</A>,		<FONT COLOR=#0000FF>/* free */</FONT>
	<A HREF="#bsd_init">bsd_init</A>,		<FONT COLOR=#0000FF>/* init */</FONT>
	<A HREF="#bsd_reset">bsd_reset</A>,		<FONT COLOR=#0000FF>/* reset */</FONT>
	<A HREF="#bsd_compress">bsd_compress</A>,		<FONT COLOR=#0000FF>/* compress */</FONT>
	<A HREF="#bsd_decompress">bsd_decompress</A>,		<FONT COLOR=#0000FF>/* decompress */</FONT>
	<A HREF="#bsd_incomp">bsd_incomp</A>,		<FONT COLOR=#0000FF>/* incomp */</FONT>
	<A HREF="#bsd_stats">bsd_stats</A>		<FONT COLOR=#0000FF>/* comp_stat */</FONT>
};

<FONT COLOR=#0000FF>/*************************************************************
 * Module support routines
 *************************************************************/</FONT>

<FONT COLOR="#298C52">int</FONT> <A NAME="init_module">init_module</A>(<FONT COLOR="#298C52">void</FONT>)
{
	<FONT COLOR="#298C52">int</FONT> answer = <A HREF="isdn_ppp.c.shtml#isdn_ppp_register_compressor">isdn_ppp_register_compressor</A> (&amp;ippp_bsd_compress);
	<FONT COLOR="#298C52">if</FONT> (answer == 0)
		printk (KERN_INFO <FONT COLOR="#FF0000">"PPP BSD Compression module registered\n"</FONT>);
	<FONT COLOR="#298C52">return</FONT> answer;
}

<FONT COLOR="#298C52">void</FONT> <A NAME="cleanup_module">cleanup_module</A>(<FONT COLOR="#298C52">void</FONT>)
{
	<A HREF="isdn_ppp.c.shtml#isdn_ppp_unregister_compressor">isdn_ppp_unregister_compressor</A> (&amp;ippp_bsd_compress);
}
</BODY>

</HTML>
