<HTML>

<!-- Generated by c2html-1.0, Copyright 1998 by Dave Whittington -->
<HEAD>
<TITLE>amd7930.c</TITLE>
<!--#include virtual="/ssi/js.shtml" -->
<!--#include virtual="/ssi/buttondefs.shtml" -->
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<TABLE WIDTH="100%">
<TR>
<TD ALIGN=LEFT WIDTH="90"><!--#include virtual="/ssi/b_home.shtml" --></TD>
<TD ALIGN=RIGHT WIDTH="90"><!--#include virtual="/ssi/b_index.shtml" --></TD>
</TR>
</TABLE>
<CENTER><H1>amd7930.c</H1></CENTER>

<HR>
<PRE>
<FONT COLOR=#0000FF>/* $Id$
 *
 * HiSax ISDN driver - chip specific routines for AMD 7930
 *
 * Author       Brent Baccala (baccala@FreeSoft.org)
 *
 *
 *
 * $Log$
 * Revision 1.2  1998/02/12 23:07:10  keil
 * change for 2.1.86 (removing FREE_READ/FREE_WRITE from [dev]_kfree_skb()
 *
 * Revision 1.1  1998/02/03 23:20:51  keil
 * New files for SPARC isdn support
 *
 * Revision 1.1  1998/01/08 04:17:12  baccala
 * ISDN comes to the Sparc.  Key points:
 *
 *    - Existing ISDN HiSax driver provides all the smarts
 *    - it compiles, runs, talks to an isolated phone switch, connects
 *      to a Cisco, pings go through
 *    - AMD 7930 support only (no DBRI yet)
 *    - no US NI-1 support (may not work on US phone system - untested)
 *    - periodic packet loss, apparently due to lost interrupts
 *    - ISDN sometimes freezes, requiring reboot before it will work again
 *
 * The code is unreliable enough to be consider alpha
 *
 *
 * Advanced Micro Devices' Am79C30A is an ISDN/audio chip used in the
 * SparcStation 1+.  The chip provides microphone and speaker interfaces
 * which provide mono-channel audio at 8K samples per second via either
 * 8-bit A-law or 8-bit mu-law encoding.  Also, the chip features an
 * ISDN BRI Line Interface Unit (LIU), I.430 S/T physical interface,
 * which performs basic D channel LAPD processing and provides raw
 * B channel data.  The digital audio channel, the two ISDN B channels,
 * and two 64 Kbps channels to the microprocessor are all interconnected
 * via a multiplexer.
 *
 * This driver interfaces to the Linux HiSax ISDN driver, which performs
 * all high-level Q.921 and Q.931 ISDN functions.  The file is not
 * itself a hardware driver; rather it uses functions exported by
 * the AMD7930 driver in the sparcaudio subsystem (drivers/sbus/audio),
 * allowing the chip to be simultaneously used for both audio and ISDN data.
 * The hardware driver does _no_ buffering, but provides several callbacks
 * which are called during interrupt service and should therefore run quickly.
 *
 * D channel transmission is performed by passing the hardware driver the
 * address and size of an skb's data area, then waiting for a callback
 * to signal successful transmission of the packet.  A task is then
 * queued to notify the HiSax driver that another packet may be transmitted.
 *
 * D channel reception is quite simple, mainly because of:
 *   1) the slow speed of the D channel - 16 kbps, and
 *   2) the presence of an 8- or 32-byte (depending on chip version) FIFO
 *      to buffer the D channel data on the chip
 * Worst case scenario of back-to-back packets with the 8 byte buffer
 * at 16 kbps yields an service time of 4 ms - long enough to preclude
 * the need for fancy buffering.  We queue a background task that copies
 * data out of the receive buffer into an skb, and the hardware driver
 * simply does nothing until we're done with the receive buffer and
 * reset it for a new packet.
 *
 * B channel processing is more complex, because of:
 *   1) the faster speed - 64 kbps,
 *   2) the lack of any on-chip buffering (it interrupts for every byte), and
 *   3) the lack of any chip support for HDLC encapsulation
 *
 * The HiSax driver can put each B channel into one of three modes -
 * L1_MODE_NULL (channel disabled), L1_MODE_TRANS (transparent data relay),
 * and L1_MODE_HDLC (HDLC encapsulation by low-level driver).
 * L1_MODE_HDLC is the most common, used for almost all "pure" digital
 * data sessions.  L1_MODE_TRANS is used for ISDN audio.
 *
 * HDLC B channel transmission is performed via a large buffer into
 * which the skb is copied while performing HDLC bit-stuffing.  A CRC
 * is computed and attached to the end of the buffer, which is then
 * passed to the low-level routines for raw transmission.  Once
 * transmission is complete, the hardware driver is set to enter HDLC
 * idle by successive transmission of mark (all 1) bytes, waiting for
 * the ISDN driver to prepare another packet for transmission and
 * deliver it.
 *
 * HDLC B channel reception is performed via an X-byte ring buffer
 * divided into N sections of X/N bytes each.  Defaults: X=256 bytes, N=4.
 * As the hardware driver notifies us that each section is full, we
 * hand it the next section and schedule a background task to peruse
 * the received section, bit-by-bit, with an HDLC decoder.  As
 * packets are detected, they are copied into a large buffer while
 * decoding HDLC bit-stuffing.  The ending CRC is verified, and if
 * it is correct, we alloc a new skb of the correct length (which we
 * now know), copy the packet into it, and hand it to the upper layers.
 * Optimization: for large packets, we hand the buffer (which also
 * happens to be an skb) directly to the upper layer after an skb_trim,
 * and alloc a new large buffer for future packets, thus avoiding a copy.
 * Then we return to HDLC processing; state is saved between calls.
 * 
 */</FONT>

<FONT COLOR=#A521F7>#define</FONT> <A HREF="asuscom.c.shtml#__NO_VERSION__">__NO_VERSION__</A>
<FONT COLOR=#A521F7>#include</FONT> <FONT COLOR="#FF0000">"hisax.h"</FONT>
<FONT COLOR=#A521F7>#include</FONT> <FONT COLOR="#FF0000">"../../sbus/audio/amd7930.h"</FONT>
<FONT COLOR=#A521F7>#include</FONT> <FONT COLOR="#FF0000">"isac.h"</FONT>
<FONT COLOR=#A521F7>#include</FONT> <FONT COLOR="#FF0000">"isdnl1.h"</FONT>
<FONT COLOR=#A521F7>#include</FONT> <FONT COLOR="#FF0000">"rawhdlc.h"</FONT>
<FONT COLOR=#A521F7>#include</FONT> &lt;linux/interrupt.h&gt;

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">const</FONT> <FONT COLOR="#298C52">char</FONT> *amd7930_revision = <FONT COLOR="#FF0000">"$Revision$"</FONT>;

<FONT COLOR=#A521F7>#define</FONT> RCV_BUFSIZE	1024	<FONT COLOR=#0000FF>/* Size of raw receive buffer in bytes */</FONT>
<FONT COLOR=#A521F7>#define</FONT> RCV_BUFBLKS	4	<FONT COLOR=#0000FF>/* Number of blocks to divide buffer into
				 * (must divide RCV_BUFSIZE) */</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT> Bchan_fill_fifo(<FONT COLOR="#298C52">struct</FONT> BCState *, <FONT COLOR="#298C52">struct</FONT> sk_buff *);

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_xmt_bh(<FONT COLOR="#298C52">struct</FONT> BCState *bcs)
{
	<FONT COLOR="#298C52">struct</FONT> sk_buff *skb;

	<FONT COLOR="#298C52">if</FONT> (bcs-&gt;hw.amd7930.tx_skb != NULL) {
		dev_kfree_skb(bcs-&gt;hw.amd7930.tx_skb);
		bcs-&gt;hw.amd7930.tx_skb = NULL;
	}

	<FONT COLOR="#298C52">if</FONT> ((skb = skb_dequeue(&amp;bcs-&gt;squeue))) {
		Bchan_fill_fifo(bcs, skb);
	} <FONT COLOR="#298C52">else</FONT> {
		clear_bit(<A HREF="hisax.h.shtml#BC_FLG_BUSY">BC_FLG_BUSY</A>, &amp;bcs-&gt;Flag);
		bcs-&gt;event |= 1 &lt;&lt; <A HREF="isdnl1.h.shtml#B_XMTBUFREADY">B_XMTBUFREADY</A>;
		queue_task(&amp;bcs-&gt;tqueue, &amp;tq_immediate);
		mark_bh(IMMEDIATE_BH);
	}
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_xmit_callback(<FONT COLOR="#298C52">struct</FONT> BCState *bcs)
{
	queue_task(&amp;bcs-&gt;hw.amd7930.tq_xmt, &amp;tq_immediate);
	mark_bh(IMMEDIATE_BH);
}

<FONT COLOR=#0000FF>/* B channel transmission: two modes (three, if you count L1_MODE_NULL)
 *
 * L1_MODE_HDLC - We need to do HDLC encapsulation before transmiting
 * the packet (i.e. make_raw_hdlc_data).  Since this can be a
 * time-consuming operation, our completion callback just schedules
 * a bottom half to do encapsulation for the next packet.  In between,
 * the link will just idle
 *
 * L1_MODE_TRANS - Data goes through, well, transparent.  No HDLC encap,
 * and we can't just let the link idle, so the "bottom half" actually
 * gets called during the top half (it's our callback routine in this case),
 * but it's a lot faster now since we don't call make_raw_hdlc_data
 */</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_fill_fifo(<FONT COLOR="#298C52">struct</FONT> BCState *bcs, <FONT COLOR="#298C52">struct</FONT> sk_buff *skb)
{
	<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs = bcs-&gt;cs;
	<FONT COLOR="#298C52">int</FONT> len;

	<FONT COLOR="#298C52">if</FONT> ((cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_HSCX">L1_DEB_HSCX</A>) || (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_HSCX_FIFO">L1_DEB_HSCX_FIFO</A>)) {
		<FONT COLOR="#298C52">char</FONT> tmp[1024];
		<FONT COLOR="#298C52">char</FONT> *t = tmp;

		t += sprintf(t, <FONT COLOR="#FF0000">"amd7930_fill_fifo %c cnt %d"</FONT>,
			     bcs-&gt;channel ? <FONT COLOR="#FF0000">'B'</FONT> : <FONT COLOR="#FF0000">'A'</FONT>, skb-&gt;len);
		<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_HSCX_FIFO">L1_DEB_HSCX_FIFO</A>)
			<A HREF="q931.c.shtml#QuickHex">QuickHex</A>(t, skb-&gt;data, skb-&gt;len);
		<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
	}

	<FONT COLOR="#298C52">if</FONT> (bcs-&gt;mode == <A HREF="hisax.h.shtml#L1_MODE_HDLC">L1_MODE_HDLC</A>) {
		len = make_raw_hdlc_data(skb-&gt;data, skb-&gt;len,
					 bcs-&gt;hw.amd7930.tx_buff, <A HREF="hisax.h.shtml#RAW_BUFMAX">RAW_BUFMAX</A>);
		<FONT COLOR="#298C52">if</FONT> (len &gt; 0)
			amd7930_bxmit(0, bcs-&gt;channel,
				      bcs-&gt;hw.amd7930.tx_buff, len,
				      (<FONT COLOR="#298C52">void</FONT> *) &amp;Bchan_xmit_callback,
				      (<FONT COLOR="#298C52">void</FONT> *) bcs);
		dev_kfree_skb(skb);
	} <FONT COLOR="#298C52">else</FONT> <FONT COLOR="#298C52">if</FONT> (bcs-&gt;mode == <A HREF="hisax.h.shtml#L1_MODE_TRANS">L1_MODE_TRANS</A>) {
		amd7930_bxmit(0, bcs-&gt;channel,
			      bcs-&gt;hw.amd7930.tx_buff, skb-&gt;len,
			      (<FONT COLOR="#298C52">void</FONT> *) &amp;Bchan_xmt_bh,
			      (<FONT COLOR="#298C52">void</FONT> *) bcs);
		bcs-&gt;hw.amd7930.tx_skb = skb;
	} <FONT COLOR="#298C52">else</FONT> {
		dev_kfree_skb(skb);
	}
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_mode(<FONT COLOR="#298C52">struct</FONT> BCState *bcs, <FONT COLOR="#298C52">int</FONT> mode, <FONT COLOR="#298C52">int</FONT> bc)
{
	<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs = bcs-&gt;cs;

	<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_HSCX">L1_DEB_HSCX</A>) {
		<FONT COLOR="#298C52">char</FONT> tmp[40];
		sprintf(tmp, <FONT COLOR="#FF0000">"AMD 7930 mode %d bchan %d/%d"</FONT>,
			mode, bc, bcs-&gt;channel);
		<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
	}
	bcs-&gt;mode = mode;
}

<FONT COLOR=#0000FF>/* Bchan_l2l1 is the entry point for upper layer routines that want to
 * transmit on the B channel.  PH_DATA_REQ is a normal packet that
 * we either start transmitting (if idle) or queue (if busy).
 * PH_PULL_REQ can be called to request a callback message (PH_PULL_CNF)
 * once the link is idle.  After a "pull" callback, the upper layer
 * routines can use PH_PULL_IND to send data.
 */</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_l2l1(<FONT COLOR="#298C52">struct</FONT> PStack *st, <FONT COLOR="#298C52">int</FONT> pr, <FONT COLOR="#298C52">void</FONT> *arg)
{
	<FONT COLOR="#298C52">struct</FONT> sk_buff *skb = arg;

	<FONT COLOR="#298C52">switch</FONT> (pr) {
		<FONT COLOR="#298C52">case</FONT> (PH_DATA_REQ):
			<FONT COLOR="#298C52">if</FONT> (test_bit(<A HREF="hisax.h.shtml#BC_FLG_BUSY">BC_FLG_BUSY</A>, &amp;st-&gt;l1.bcs-&gt;Flag)) {
				skb_queue_tail(&amp;st-&gt;l1.bcs-&gt;squeue, skb);
			} <FONT COLOR="#298C52">else</FONT> {
				test_and_set_bit(<A HREF="hisax.h.shtml#BC_FLG_BUSY">BC_FLG_BUSY</A>, &amp;st-&gt;l1.bcs-&gt;Flag);
				Bchan_fill_fifo(st-&gt;l1.bcs, skb);
			}
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> (PH_PULL_IND):
			<FONT COLOR="#298C52">if</FONT> (test_bit(<A HREF="hisax.h.shtml#BC_FLG_BUSY">BC_FLG_BUSY</A>, &amp;st-&gt;l1.bcs-&gt;Flag)) {
				printk(KERN_WARNING <FONT COLOR="#FF0000">"amd7930: this shouldn't happen\n"</FONT>);
				<FONT COLOR="#298C52">break</FONT>;
			}
			test_and_set_bit(<A HREF="hisax.h.shtml#BC_FLG_BUSY">BC_FLG_BUSY</A>, &amp;st-&gt;l1.bcs-&gt;Flag);
			Bchan_fill_fifo(st-&gt;l1.bcs, skb);
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> (PH_PULL_REQ):
			<FONT COLOR="#298C52">if</FONT> (!test_bit(<A HREF="hisax.h.shtml#BC_FLG_BUSY">BC_FLG_BUSY</A>, &amp;st-&gt;l1.bcs-&gt;Flag)) {
				clear_bit(<A HREF="hisax.h.shtml#FLG_L1_PULL_REQ">FLG_L1_PULL_REQ</A>, &amp;st-&gt;l1.Flags);
				st-&gt;l1.l1l2(st, PH_PULL_CNF, NULL);
			} <FONT COLOR="#298C52">else</FONT>
				set_bit(<A HREF="hisax.h.shtml#FLG_L1_PULL_REQ">FLG_L1_PULL_REQ</A>, &amp;st-&gt;l1.Flags);
			<FONT COLOR="#298C52">break</FONT>;
	}
}

<FONT COLOR=#0000FF>/* Receiver callback and bottom half - decodes HDLC at leisure (if
 * L1_MODE_HDLC) and passes newly received skb on via bcs-&gt;rqueue.  If
 * a large packet is received, stick rv_skb (the buffer that the
 * packet has been decoded into) on the receive queue and alloc a new
 * (large) skb to act as buffer for future receives.  If a small
 * packet is received, leave rv_skb alone, alloc a new skb of the
 * correct size, and copy the packet into it
 */</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_recv_callback(<FONT COLOR="#298C52">struct</FONT> BCState *bcs)
{
	<FONT COLOR="#298C52">struct</FONT> amd7930_hw *hw = &amp;bcs-&gt;hw.amd7930;

	hw-&gt;rv_buff_in += RCV_BUFSIZE/RCV_BUFBLKS;
	hw-&gt;rv_buff_in %= RCV_BUFSIZE;

	<FONT COLOR="#298C52">if</FONT> (hw-&gt;rv_buff_in != hw-&gt;rv_buff_out) {
		amd7930_brecv(0, bcs-&gt;channel,
			      hw-&gt;rv_buff + hw-&gt;rv_buff_in,
			      RCV_BUFSIZE/RCV_BUFBLKS,
			      (<FONT COLOR="#298C52">void</FONT> *) &amp;Bchan_recv_callback, (<FONT COLOR="#298C52">void</FONT> *) bcs);
	}

	queue_task(&amp;hw-&gt;tq_rcv, &amp;tq_immediate);
	mark_bh(IMMEDIATE_BH);
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_rcv_bh(<FONT COLOR="#298C52">struct</FONT> BCState *bcs)
{
	<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs = bcs-&gt;cs;
	<FONT COLOR="#298C52">struct</FONT> amd7930_hw *hw = &amp;bcs-&gt;hw.amd7930;
	<FONT COLOR="#298C52">struct</FONT> sk_buff *skb;
	<FONT COLOR="#298C52">int</FONT> len;

	<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_HSCX">L1_DEB_HSCX</A>) {
		<FONT COLOR="#298C52">char</FONT> tmp[1024];

		sprintf(tmp, <FONT COLOR="#FF0000">"amd7930_Bchan_rcv (%d/%d)"</FONT>,
			hw-&gt;rv_buff_in, hw-&gt;rv_buff_out);
		<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
		<A HREF="q931.c.shtml#QuickHex">QuickHex</A>(tmp, hw-&gt;rv_buff + hw-&gt;rv_buff_out,
			 RCV_BUFSIZE/RCV_BUFBLKS);
		<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
	}

	<FONT COLOR="#298C52">do</FONT> {
		<FONT COLOR="#298C52">if</FONT> (bcs-&gt;mode == <A HREF="hisax.h.shtml#L1_MODE_HDLC">L1_MODE_HDLC</A>) {
			<FONT COLOR="#298C52">while</FONT> ((len = read_raw_hdlc_data(hw-&gt;hdlc_state,
							 hw-&gt;rv_buff + hw-&gt;rv_buff_out, RCV_BUFSIZE/RCV_BUFBLKS,
							 hw-&gt;rv_skb-&gt;tail, <A HREF="hisax.h.shtml#HSCX_BUFMAX">HSCX_BUFMAX</A>))) {
				<FONT COLOR="#298C52">if</FONT> (len &gt; 0 &amp;&amp; (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_HSCX_FIFO">L1_DEB_HSCX_FIFO</A>)) {
					<FONT COLOR="#298C52">char</FONT> tmp[1024];
					<FONT COLOR="#298C52">char</FONT> *t = tmp;

					t += sprintf(t, <FONT COLOR="#FF0000">"amd7930_Bchan_rcv %c cnt %d"</FONT>, bcs-&gt;channel ? <FONT COLOR="#FF0000">'B'</FONT> : <FONT COLOR="#FF0000">'A'</FONT>, len);
					<A HREF="q931.c.shtml#QuickHex">QuickHex</A>(t, hw-&gt;rv_skb-&gt;tail, len);
					<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
				}

				<FONT COLOR="#298C52">if</FONT> (len &gt; <A HREF="hisax.h.shtml#HSCX_BUFMAX">HSCX_BUFMAX</A>/2) {
					<FONT COLOR=#0000FF>/* Large packet received */</FONT>

					<FONT COLOR="#298C52">if</FONT> (!(skb = dev_alloc_skb(<A HREF="hisax.h.shtml#HSCX_BUFMAX">HSCX_BUFMAX</A>))) {
						printk(KERN_WARNING <FONT COLOR="#FF0000">"amd7930: receive out of memory"</FONT>);
					} <FONT COLOR="#298C52">else</FONT> {
						skb_put(hw-&gt;rv_skb, len);
						skb_queue_tail(&amp;bcs-&gt;rqueue, hw-&gt;rv_skb);
						hw-&gt;rv_skb = skb;
						bcs-&gt;event |= 1 &lt;&lt; <A HREF="isdnl1.h.shtml#B_RCVBUFREADY">B_RCVBUFREADY</A>;
						queue_task(&amp;bcs-&gt;tqueue, &amp;tq_immediate);
					}
				} <FONT COLOR="#298C52">else</FONT> <FONT COLOR="#298C52">if</FONT> (len &gt; 0) {
					<FONT COLOR=#0000FF>/* Small packet received */</FONT>

					<FONT COLOR="#298C52">if</FONT> (!(skb = dev_alloc_skb(len))) {
						printk(KERN_WARNING <FONT COLOR="#FF0000">"amd7930: receive out of memory\n"</FONT>);
					} <FONT COLOR="#298C52">else</FONT> {
						memcpy(skb_put(skb, len), hw-&gt;rv_skb-&gt;tail, len);
						skb_queue_tail(&amp;bcs-&gt;rqueue, skb);
						bcs-&gt;event |= 1 &lt;&lt; <A HREF="isdnl1.h.shtml#B_RCVBUFREADY">B_RCVBUFREADY</A>;
						queue_task(&amp;bcs-&gt;tqueue, &amp;tq_immediate);
						mark_bh(IMMEDIATE_BH);
					}
				} <FONT COLOR="#298C52">else</FONT> {
					<FONT COLOR=#0000FF>/* Reception Error */</FONT>
					<FONT COLOR=#0000FF>/* printk("amd7930: B channel receive error\n"); */</FONT>
				}
			}
		} <FONT COLOR="#298C52">else</FONT> <FONT COLOR="#298C52">if</FONT> (bcs-&gt;mode == <A HREF="hisax.h.shtml#L1_MODE_TRANS">L1_MODE_TRANS</A>) {
			<FONT COLOR="#298C52">if</FONT> (!(skb = dev_alloc_skb(RCV_BUFSIZE/RCV_BUFBLKS))) {
				printk(KERN_WARNING <FONT COLOR="#FF0000">"amd7930: receive out of memory\n"</FONT>);
			} <FONT COLOR="#298C52">else</FONT> {
				memcpy(skb_put(skb, RCV_BUFSIZE/RCV_BUFBLKS),
				       hw-&gt;rv_buff + hw-&gt;rv_buff_out,
				       RCV_BUFSIZE/RCV_BUFBLKS);
				skb_queue_tail(&amp;bcs-&gt;rqueue, skb);
				bcs-&gt;event |= 1 &lt;&lt; <A HREF="isdnl1.h.shtml#B_RCVBUFREADY">B_RCVBUFREADY</A>;
				queue_task(&amp;bcs-&gt;tqueue, &amp;tq_immediate);
				mark_bh(IMMEDIATE_BH);
			}
		}

		<FONT COLOR="#298C52">if</FONT> (hw-&gt;rv_buff_in == hw-&gt;rv_buff_out) {
			<FONT COLOR=#0000FF>/* Buffer was filled up - need to restart receiver */</FONT>
			amd7930_brecv(0, bcs-&gt;channel,
				      hw-&gt;rv_buff + hw-&gt;rv_buff_in,
				      RCV_BUFSIZE/RCV_BUFBLKS,
				      (<FONT COLOR="#298C52">void</FONT> *) &amp;Bchan_recv_callback,
				      (<FONT COLOR="#298C52">void</FONT> *) bcs);
		}

		hw-&gt;rv_buff_out += RCV_BUFSIZE/RCV_BUFBLKS;
		hw-&gt;rv_buff_out %= RCV_BUFSIZE;

	} <FONT COLOR="#298C52">while</FONT> (hw-&gt;rv_buff_in != hw-&gt;rv_buff_out);
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_close(<FONT COLOR="#298C52">struct</FONT> BCState *bcs)
{
	<FONT COLOR="#298C52">struct</FONT> sk_buff *skb;

	Bchan_mode(bcs, 0, 0);
	amd7930_bclose(0, bcs-&gt;channel);

	<FONT COLOR="#298C52">if</FONT> (test_bit(<A HREF="hisax.h.shtml#BC_FLG_INIT">BC_FLG_INIT</A>, &amp;bcs-&gt;Flag)) {
		<FONT COLOR="#298C52">while</FONT> ((skb = skb_dequeue(&amp;bcs-&gt;rqueue))) {
			dev_kfree_skb(skb);
		}
		<FONT COLOR="#298C52">while</FONT> ((skb = skb_dequeue(&amp;bcs-&gt;squeue))) {
			dev_kfree_skb(skb);
		}
	}
	test_and_clear_bit(<A HREF="hisax.h.shtml#BC_FLG_INIT">BC_FLG_INIT</A>, &amp;bcs-&gt;Flag);
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">int</FONT>
Bchan_open(<FONT COLOR="#298C52">struct</FONT> BCState *bcs)
{
	<FONT COLOR="#298C52">struct</FONT> amd7930_hw *hw = &amp;bcs-&gt;hw.amd7930;

	<FONT COLOR="#298C52">if</FONT> (!test_and_set_bit(<A HREF="hisax.h.shtml#BC_FLG_INIT">BC_FLG_INIT</A>, &amp;bcs-&gt;Flag)) {
		skb_queue_head_init(&amp;bcs-&gt;rqueue);
		skb_queue_head_init(&amp;bcs-&gt;squeue);
	}
	test_and_clear_bit(<A HREF="hisax.h.shtml#BC_FLG_BUSY">BC_FLG_BUSY</A>, &amp;bcs-&gt;Flag);

	amd7930_bopen(0, bcs-&gt;channel, 0xff);
	hw-&gt;rv_buff_in = 0;
	hw-&gt;rv_buff_out = 0;
	hw-&gt;tx_skb = NULL;
	init_hdlc_state(hw-&gt;hdlc_state, 0);
	amd7930_brecv(0, bcs-&gt;channel,
		      hw-&gt;rv_buff + hw-&gt;rv_buff_in, RCV_BUFSIZE/RCV_BUFBLKS,
		      (<FONT COLOR="#298C52">void</FONT> *) &amp;Bchan_recv_callback, (<FONT COLOR="#298C52">void</FONT> *) bcs);

	bcs-&gt;event = 0;
	bcs-&gt;tx_cnt = 0;
	<FONT COLOR="#298C52">return</FONT> (0);
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_init(<FONT COLOR="#298C52">struct</FONT> BCState *bcs)
{
	<FONT COLOR="#298C52">if</FONT> (!(bcs-&gt;hw.amd7930.tx_buff = kmalloc(<A HREF="hisax.h.shtml#RAW_BUFMAX">RAW_BUFMAX</A>, GFP_ATOMIC))) {
		printk(KERN_WARNING
		       <FONT COLOR="#FF0000">"HiSax: No memory for amd7930.tx_buff\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT>;
	}
	<FONT COLOR="#298C52">if</FONT> (!(bcs-&gt;hw.amd7930.rv_buff = kmalloc(RCV_BUFSIZE, GFP_ATOMIC))) {
		printk(KERN_WARNING
		       <FONT COLOR="#FF0000">"HiSax: No memory for amd7930.rv_buff\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT>;
	}
	<FONT COLOR="#298C52">if</FONT> (!(bcs-&gt;hw.amd7930.rv_skb = dev_alloc_skb(<A HREF="hisax.h.shtml#HSCX_BUFMAX">HSCX_BUFMAX</A>))) {
		printk(KERN_WARNING
		       <FONT COLOR="#FF0000">"HiSax: No memory for amd7930.rv_skb\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT>;
	}
	<FONT COLOR="#298C52">if</FONT> (!(bcs-&gt;hw.amd7930.hdlc_state = kmalloc(<FONT COLOR="#298C52">sizeof</FONT>(<FONT COLOR="#298C52">struct</FONT> hdlc_state),
						   GFP_ATOMIC))) {
		printk(KERN_WARNING
		       <FONT COLOR="#FF0000">"HiSax: No memory for amd7930.hdlc_state\n"</FONT>);
		<FONT COLOR="#298C52">return</FONT>;
	}

	bcs-&gt;hw.amd7930.tq_rcv.sync = 0;
	bcs-&gt;hw.amd7930.tq_rcv.routine = (<FONT COLOR="#298C52">void</FONT> (*)(<FONT COLOR="#298C52">void</FONT> *)) &amp;Bchan_rcv_bh;
	bcs-&gt;hw.amd7930.tq_rcv.data = (<FONT COLOR="#298C52">void</FONT> *) bcs;

	bcs-&gt;hw.amd7930.tq_xmt.sync = 0;
	bcs-&gt;hw.amd7930.tq_xmt.routine = (<FONT COLOR="#298C52">void</FONT> (*)(<FONT COLOR="#298C52">void</FONT> *)) &amp;Bchan_xmt_bh;
	bcs-&gt;hw.amd7930.tq_xmt.data = (<FONT COLOR="#298C52">void</FONT> *) bcs;
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
Bchan_manl1(<FONT COLOR="#298C52">struct</FONT> PStack *st, <FONT COLOR="#298C52">int</FONT> pr,
	  <FONT COLOR="#298C52">void</FONT> *arg)
{
	<FONT COLOR="#298C52">switch</FONT> (pr) {
		<FONT COLOR="#298C52">case</FONT> (PH_ACTIVATE_REQ):
			test_and_set_bit(<A HREF="hisax.h.shtml#BC_FLG_ACTIV">BC_FLG_ACTIV</A>, &amp;st-&gt;l1.bcs-&gt;Flag);
			Bchan_mode(st-&gt;l1.bcs, st-&gt;l1.mode, st-&gt;l1.bc);
			st-&gt;l1.l1man(st, PH_ACTIVATE_CNF, NULL);
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> (PH_DEACTIVATE_REQ):
			<FONT COLOR="#298C52">if</FONT> (!test_bit(<A HREF="hisax.h.shtml#BC_FLG_BUSY">BC_FLG_BUSY</A>, &amp;st-&gt;l1.bcs-&gt;Flag))
				Bchan_mode(st-&gt;l1.bcs, 0, 0);
			test_and_clear_bit(<A HREF="hisax.h.shtml#BC_FLG_ACTIV">BC_FLG_ACTIV</A>, &amp;st-&gt;l1.bcs-&gt;Flag);
			<FONT COLOR="#298C52">break</FONT>;
	}
}

<FONT COLOR="#298C52">int</FONT>
setstack_amd7930(<FONT COLOR="#298C52">struct</FONT> PStack *st, <FONT COLOR="#298C52">struct</FONT> BCState *bcs)
{
	<FONT COLOR="#298C52">if</FONT> (Bchan_open(bcs))
		<FONT COLOR="#298C52">return</FONT> (-1);
	st-&gt;l1.bcs = bcs;
	st-&gt;l2.l2l1 = Bchan_l2l1;
	st-&gt;ma.manl1 = Bchan_manl1;
	<A HREF="lmgr.c.shtml#setstack_manager">setstack_manager</A>(st);
	bcs-&gt;st = st;
	<FONT COLOR="#298C52">return</FONT> (0);
}


<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
amd7930_drecv_callback(<FONT COLOR="#298C52">void</FONT> *arg, <FONT COLOR="#298C52">int</FONT> error, <FONT COLOR="#298C52">unsigned</FONT> <FONT COLOR="#298C52">int</FONT> count)
{
	<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs = (<FONT COLOR="#298C52">struct</FONT> IsdnCardState *) arg;
	<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">struct</FONT> tq_struct task;
	<FONT COLOR="#298C52">struct</FONT> sk_buff *skb;

        <FONT COLOR=#0000FF>/* NOTE: This function is called directly from an interrupt handler */</FONT>

	<FONT COLOR="#298C52">if</FONT> (1) {
		<FONT COLOR="#298C52">if</FONT> (!(skb = alloc_skb(count, GFP_ATOMIC)))
			printk(KERN_WARNING <FONT COLOR="#FF0000">"HiSax: D receive out of memory\n"</FONT>);
		<FONT COLOR="#298C52">else</FONT> {
			memcpy(skb_put(skb, count), cs-&gt;rcvbuf, count);
			skb_queue_tail(&amp;cs-&gt;rq, skb);
		}

		task.routine = (<FONT COLOR="#298C52">void</FONT> *) <A HREF="isdnl1.c.shtml#DChannel_proc_rcv">DChannel_proc_rcv</A>;
		task.data = (<FONT COLOR="#298C52">void</FONT> *) cs;
		queue_task(&amp;task, &amp;tq_immediate);
		mark_bh(IMMEDIATE_BH);
	}

	<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_ISAC_FIFO">L1_DEB_ISAC_FIFO</A>) {
		<FONT COLOR="#298C52">char</FONT> tmp[128];
		<FONT COLOR="#298C52">char</FONT> *t = tmp;

		t += sprintf(t, <FONT COLOR="#FF0000">"amd7930 Drecv cnt %d"</FONT>, count);
		<FONT COLOR="#298C52">if</FONT> (error) t += sprintf(t, <FONT COLOR="#FF0000">" ERR %x"</FONT>, error);
		<A HREF="q931.c.shtml#QuickHex">QuickHex</A>(t, cs-&gt;rcvbuf, count);
		<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
	}

	amd7930_drecv(0, cs-&gt;rcvbuf, <A HREF="hisax.h.shtml#MAX_DFRAME_LEN">MAX_DFRAME_LEN</A>,
		      &amp;amd7930_drecv_callback, cs);
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
amd7930_dxmit_callback(<FONT COLOR="#298C52">void</FONT> *arg, <FONT COLOR="#298C52">int</FONT> error)
{
	<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs = (<FONT COLOR="#298C52">struct</FONT> IsdnCardState *) arg;
	<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">struct</FONT> tq_struct task;

        <FONT COLOR=#0000FF>/* NOTE: This function is called directly from an interrupt handler */</FONT>

	<FONT COLOR=#0000FF>/* may wish to do retransmission here, if error indicates collision */</FONT>

	<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_ISAC_FIFO">L1_DEB_ISAC_FIFO</A>) {
		<FONT COLOR="#298C52">char</FONT> tmp[128];
		<FONT COLOR="#298C52">char</FONT> *t = tmp;

		t += sprintf(t, <FONT COLOR="#FF0000">"amd7930 Dxmit cnt %d"</FONT>, cs-&gt;tx_skb-&gt;len);
		<FONT COLOR="#298C52">if</FONT> (error) t += sprintf(t, <FONT COLOR="#FF0000">" ERR %x"</FONT>, error);
		<A HREF="q931.c.shtml#QuickHex">QuickHex</A>(t, cs-&gt;tx_skb-&gt;data, cs-&gt;tx_skb-&gt;len);
		<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
	}

	cs-&gt;tx_skb = NULL;

	task.routine = (<FONT COLOR="#298C52">void</FONT> *) <A HREF="isdnl1.c.shtml#DChannel_proc_xmt">DChannel_proc_xmt</A>;
	task.data = (<FONT COLOR="#298C52">void</FONT> *) cs;
	queue_task(&amp;task, &amp;tq_immediate);
	mark_bh(IMMEDIATE_BH);
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
amd7930_Dchan_l2l1(<FONT COLOR="#298C52">struct</FONT> PStack *st, <FONT COLOR="#298C52">int</FONT> pr, <FONT COLOR="#298C52">void</FONT> *arg)
{
	<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs = (<FONT COLOR="#298C52">struct</FONT> IsdnCardState *) st-&gt;l1.hardware;
	<FONT COLOR="#298C52">struct</FONT> sk_buff *skb = arg;
	<FONT COLOR="#298C52">char</FONT> str[64];

	<FONT COLOR="#298C52">switch</FONT> (pr) {
		<FONT COLOR="#298C52">case</FONT> (PH_DATA_REQ):
			<FONT COLOR="#298C52">if</FONT> (cs-&gt;tx_skb) {
				skb_queue_tail(&amp;cs-&gt;sq, skb);
<FONT COLOR=#A521F7>#ifdef</FONT> <A HREF="isdnl1.h.shtml#L2FRAME_DEBUG">L2FRAME_DEBUG</A>		<FONT COLOR=#0000FF>/* psa */</FONT>
				<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_LAPD">L1_DEB_LAPD</A>)
					<A HREF="isdnl1.c.shtml#Logl2Frame">Logl2Frame</A>(cs, skb, <FONT COLOR="#FF0000">"PH_DATA Queued"</FONT>, 0);
<FONT COLOR=#A521F7>#endif</FONT>
			} <FONT COLOR="#298C52">else</FONT> {
				<FONT COLOR="#298C52">if</FONT> ((cs-&gt;dlogflag) &amp;&amp; (!(skb-&gt;data[2] &amp; 1))) {
					<FONT COLOR=#0000FF>/* I-FRAME */</FONT>
					<A HREF="q931.c.shtml#LogFrame">LogFrame</A>(cs, skb-&gt;data, skb-&gt;len);
					sprintf(str, <FONT COLOR="#FF0000">"Q.931 frame user-&gt;network tei %d"</FONT>, st-&gt;l2.tei);
					<A HREF="q931.c.shtml#dlogframe">dlogframe</A>(cs, skb-&gt;data+4, skb-&gt;len-4,
						  str);
				}
				cs-&gt;tx_skb = skb;
				cs-&gt;tx_cnt = 0;
<FONT COLOR=#A521F7>#ifdef</FONT> <A HREF="isdnl1.h.shtml#L2FRAME_DEBUG">L2FRAME_DEBUG</A>		<FONT COLOR=#0000FF>/* psa */</FONT>
				<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_LAPD">L1_DEB_LAPD</A>)
					<A HREF="isdnl1.c.shtml#Logl2Frame">Logl2Frame</A>(cs, skb, <FONT COLOR="#FF0000">"PH_DATA"</FONT>, 0);
<FONT COLOR=#A521F7>#endif</FONT>
				amd7930_dxmit(0, skb-&gt;data, skb-&gt;len,
					      &amp;amd7930_dxmit_callback, cs);
			}
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> (PH_PULL_IND):
			<FONT COLOR="#298C52">if</FONT> (cs-&gt;tx_skb) {
				<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_WARN">L1_DEB_WARN</A>)
					<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, <FONT COLOR="#FF0000">" l2l1 tx_skb exist this shouldn't happen"</FONT>);
				skb_queue_tail(&amp;cs-&gt;sq, skb);
				<FONT COLOR="#298C52">break</FONT>;
			}
			<FONT COLOR="#298C52">if</FONT> ((cs-&gt;dlogflag) &amp;&amp; (!(skb-&gt;data[2] &amp; 1))) {	<FONT COLOR=#0000FF>/* I-FRAME */</FONT>
				<A HREF="q931.c.shtml#LogFrame">LogFrame</A>(cs, skb-&gt;data, skb-&gt;len);
				sprintf(str, <FONT COLOR="#FF0000">"Q.931 frame user-&gt;network tei %d"</FONT>, st-&gt;l2.tei);
				<A HREF="q931.c.shtml#dlogframe">dlogframe</A>(cs, skb-&gt;data + 4, skb-&gt;len - 4,
					  str);
			}
			cs-&gt;tx_skb = skb;
			cs-&gt;tx_cnt = 0;
<FONT COLOR=#A521F7>#ifdef</FONT> <A HREF="isdnl1.h.shtml#L2FRAME_DEBUG">L2FRAME_DEBUG</A>		<FONT COLOR=#0000FF>/* psa */</FONT>
			<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_LAPD">L1_DEB_LAPD</A>)
				<A HREF="isdnl1.c.shtml#Logl2Frame">Logl2Frame</A>(cs, skb, <FONT COLOR="#FF0000">"PH_DATA_PULLED"</FONT>, 0);
<FONT COLOR=#A521F7>#endif</FONT>
			amd7930_dxmit(0, cs-&gt;tx_skb-&gt;data, cs-&gt;tx_skb-&gt;len,
				      &amp;amd7930_dxmit_callback, cs);
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> (PH_PULL_REQ):
<FONT COLOR=#A521F7>#ifdef</FONT> <A HREF="isdnl1.h.shtml#L2FRAME_DEBUG">L2FRAME_DEBUG</A>		<FONT COLOR=#0000FF>/* psa */</FONT>
			<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_LAPD">L1_DEB_LAPD</A>)
				<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, <FONT COLOR="#FF0000">"-&gt; PH_REQUEST_PULL"</FONT>);
<FONT COLOR=#A521F7>#endif</FONT>
			<FONT COLOR="#298C52">if</FONT> (!cs-&gt;tx_skb) {
				test_and_clear_bit(<A HREF="hisax.h.shtml#FLG_L1_PULL_REQ">FLG_L1_PULL_REQ</A>, &amp;st-&gt;l1.Flags);
				st-&gt;l1.l1l2(st, PH_PULL_CNF, NULL);
			} <FONT COLOR="#298C52">else</FONT>
				test_and_set_bit(<A HREF="hisax.h.shtml#FLG_L1_PULL_REQ">FLG_L1_PULL_REQ</A>, &amp;st-&gt;l1.Flags);
			<FONT COLOR="#298C52">break</FONT>;
	}
}

<FONT COLOR="#298C52">int</FONT>
setDstack_amd7930(<FONT COLOR="#298C52">struct</FONT> PStack *st, <FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs)
{
	st-&gt;l2.l2l1 = amd7930_Dchan_l2l1;
	<FONT COLOR="#298C52">if</FONT> (! cs-&gt;rcvbuf) {
		printk(<FONT COLOR="#FF0000">"setDstack_amd7930: No cs-&gt;rcvbuf!\n"</FONT>);
	} <FONT COLOR="#298C52">else</FONT> {
		amd7930_drecv(0, cs-&gt;rcvbuf, <A HREF="hisax.h.shtml#MAX_DFRAME_LEN">MAX_DFRAME_LEN</A>,
			      &amp;amd7930_drecv_callback, cs);
	}
	<FONT COLOR="#298C52">return</FONT> (0);
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
manl1_msg(<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs, <FONT COLOR="#298C52">int</FONT> msg, <FONT COLOR="#298C52">void</FONT> *arg) {
	<FONT COLOR="#298C52">struct</FONT> PStack *st;

	st = cs-&gt;stlist;
	<FONT COLOR="#298C52">while</FONT> (st) {
		st-&gt;ma.manl1(st, msg, arg);
		st = st-&gt;next;
	}
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
amd7930_new_ph(<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs)
{
	<FONT COLOR="#298C52">switch</FONT> (amd7930_get_liu_state(0)) {
	        <FONT COLOR="#298C52">case</FONT> 3:
			manl1_msg(cs, PH_POWERUP_CNF, NULL);
                        <FONT COLOR="#298C52">break</FONT>;

	        <FONT COLOR="#298C52">case</FONT> 7:
			manl1_msg(cs, PH_I4_P8_IND, NULL);
			<FONT COLOR="#298C52">break</FONT>;

	        <FONT COLOR="#298C52">case</FONT> 8:
			manl1_msg(cs, PH_RSYNC_IND, NULL);
			<FONT COLOR="#298C52">break</FONT>;
	}
}

<FONT COLOR=#0000FF>/* amd7930 LIU state change callback */</FONT>

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT>
amd7930_liu_callback(<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs)
{
	<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">struct</FONT> tq_struct task;

	<FONT COLOR="#298C52">if</FONT> (!cs)
		<FONT COLOR="#298C52">return</FONT>;

	<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_ISAC">L1_DEB_ISAC</A>) {
		<FONT COLOR="#298C52">char</FONT> tmp[32];
		sprintf(tmp, <FONT COLOR="#FF0000">"amd7930_liu state %d"</FONT>, amd7930_get_liu_state(0));
		<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
	}

	task.sync = 0;
	task.routine = (<FONT COLOR="#298C52">void</FONT> *) &amp;amd7930_new_ph;
	task.data = (<FONT COLOR="#298C52">void</FONT> *) cs;
	queue_task(&amp;task, &amp;tq_immediate);
	mark_bh(IMMEDIATE_BH);
}

<FONT COLOR="#298C52">void</FONT>
amd7930_l1cmd(<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs, <FONT COLOR="#298C52">int</FONT> msg, <FONT COLOR="#298C52">void</FONT> *arg)
{
	u_char val;
	<FONT COLOR="#298C52">char</FONT> tmp[32];
	
	<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_ISAC">L1_DEB_ISAC</A>) {
		<FONT COLOR="#298C52">char</FONT> tmp[32];
		sprintf(tmp, <FONT COLOR="#FF0000">"amd7930_l1cmd msg %x"</FONT>, msg);
		<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
	}

	<FONT COLOR="#298C52">switch</FONT>(msg) {
		<FONT COLOR="#298C52">case</FONT> PH_RESET_REQ:
			<FONT COLOR="#298C52">if</FONT> (amd7930_get_liu_state(0) &lt;= 3)
				amd7930_liu_activate(0,0);
			<FONT COLOR="#298C52">else</FONT>
				amd7930_liu_deactivate(0);
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> PH_ENABLE_REQ:
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> PH_INFO3_REQ:
			amd7930_liu_activate(0,0);
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">case</FONT> PH_TESTLOOP_REQ:
			<FONT COLOR="#298C52">break</FONT>;
		<FONT COLOR="#298C52">default</FONT>:
			<FONT COLOR="#298C52">if</FONT> (cs-&gt;debug &amp; <A HREF="isdnl1.h.shtml#L1_DEB_WARN">L1_DEB_WARN</A>) {
				sprintf(tmp, <FONT COLOR="#FF0000">"amd7930_l1cmd unknown %4x"</FONT>, msg);
				<A HREF="isdnl1.c.shtml#debugl1">debugl1</A>(cs, tmp);
			}
			<FONT COLOR="#298C52">break</FONT>;
	}
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">void</FONT> init_amd7930(<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs)
{
	Bchan_init(&amp;cs-&gt;bcs[0]);
	Bchan_init(&amp;cs-&gt;bcs[1]);
	cs-&gt;bcs[0].BC_SetStack = setstack_amd7930;
	cs-&gt;bcs[1].BC_SetStack = setstack_amd7930;
	cs-&gt;bcs[0].BC_Close = Bchan_close;
	cs-&gt;bcs[1].BC_Close = Bchan_close;
	Bchan_mode(cs-&gt;bcs, 0, 0);
	Bchan_mode(cs-&gt;bcs + 1, 0, 0);
}

<FONT COLOR="#298C52">void</FONT>
release_amd7930(<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs)
{
}

<FONT COLOR="#298C52">static</FONT> <FONT COLOR="#298C52">int</FONT>
amd7930_card_msg(<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs, <FONT COLOR="#298C52">int</FONT> mt, <FONT COLOR="#298C52">void</FONT> *arg)
{
	<FONT COLOR="#298C52">switch</FONT> (mt) {
		<FONT COLOR="#298C52">case</FONT> <A HREF="hisax.h.shtml#CARD_RESET">CARD_RESET</A>:
			<FONT COLOR="#298C52">return</FONT>(0);
		<FONT COLOR="#298C52">case</FONT> <A HREF="hisax.h.shtml#CARD_RELEASE">CARD_RELEASE</A>:
			release_amd7930(cs);
			<FONT COLOR="#298C52">return</FONT>(0);
		<FONT COLOR="#298C52">case</FONT> <A HREF="hisax.h.shtml#CARD_SETIRQ">CARD_SETIRQ</A>:
			<FONT COLOR="#298C52">return</FONT>(0);
		<FONT COLOR="#298C52">case</FONT> <A HREF="hisax.h.shtml#CARD_INIT">CARD_INIT</A>:
			cs-&gt;l1cmd = amd7930_l1cmd;
			amd7930_liu_init(0, &amp;amd7930_liu_callback, (<FONT COLOR="#298C52">void</FONT> *)cs);
			init_amd7930(cs);
			<FONT COLOR="#298C52">return</FONT>(0);
		<FONT COLOR="#298C52">case</FONT> <A HREF="hisax.h.shtml#CARD_TEST">CARD_TEST</A>:
			<FONT COLOR="#298C52">return</FONT>(0);
	}
	<FONT COLOR="#298C52">return</FONT>(0);
}

<A HREF="asuscom.c.shtml#__initfunc">__initfunc</A>(<FONT COLOR="#298C52">int</FONT>
setup_amd7930(<FONT COLOR="#298C52">struct</FONT> IsdnCard *card))
{
	<FONT COLOR="#298C52">struct</FONT> IsdnCardState *cs = card-&gt;cs;
	<FONT COLOR="#298C52">char</FONT> tmp[64];

	strcpy(tmp, amd7930_revision);
	printk(KERN_INFO <FONT COLOR="#FF0000">"HiSax: AMD7930 driver Rev. %s\n"</FONT>, HiSax_getrev(tmp));
	<FONT COLOR="#298C52">if</FONT> (cs-&gt;typ != <A HREF="hisax.h.shtml#ISDN_CTYPE_AMD7930">ISDN_CTYPE_AMD7930</A>)
		<FONT COLOR="#298C52">return</FONT> (0);

        cs-&gt;irq = amd7930_get_irqnum(0);
        <FONT COLOR="#298C52">if</FONT> (cs-&gt;irq == 0)
		<FONT COLOR="#298C52">return</FONT> (0);

	cs-&gt;cardmsg = &amp;amd7930_card_msg;

	<FONT COLOR="#298C52">return</FONT> (1);
}
</BODY>

</HTML>
